---
title: "Single-cell RNA-seq data analysis"
author:
  - "[Dresden-concept Genome Center, TU Dresden](https://genomecenter.tu-dresden.de/)"
  - "[Research Core Unit Genomics, Hannover Medical School](https://www.mhh.de/genomics)"
date: "`r format(Sys.time(), '%B, %Y')`"
geometry: margin=2cm
output:
  html_document:
    toc: true
    toc_depth: 4
    code_folding: hide
    highlight: tango
    theme: paper
bibliography: "references.bib"
---

```{r setup, warning=FALSE, message=FALSE}
# R Options
options(stringsAsFactors=FALSE, 
        "citation_format"="pandoc", 
        dplyr.summarise.inform=FALSE, 
        knitr.table.format="html",
        future.globals.maxSize=2000000000, mc.cores=4, 
        future.fork.enable=TRUE, future.plan="multicore",
        future.rng.onMisuse="ignore")

# Python needed for clustering, umap, other python packages
# Change location if necessary
Sys.setenv(RETICULATE_PYTHON = "/usr/local/bin/python3")

# Required libraries
library(Seurat) # main
library(ggplot2) # plots
library(patchwork) # combination of plots
library(magrittr) # %>% operator
library(reticulate) # required for 'leiden' clustering
library(enrichR) # functional enrichment
library(future) # multicore support for Seurat

# Other libraries we use
# Knit: knitr
# Data handling: dplyr, tidyr, purrr, stringr, Matrix, sctransform
# Tables: kableExtra, DT
# Plots: ggsci, ggpubr
# IO: openxlsx, readr, R.utils
# Annotation: biomaRt
# DEG: mast
# Functional enrichment: enrichR
# Other: sessioninfo, cerebroApp

# Knitr default options
knitr::opts_chunk$set(echo=TRUE, cache=FALSE, message=TRUE, warning=TRUE, tidy=FALSE, fig.width=10, class.source='fold-hide')
```

# Dataset description
* 10x and Smartseq2 datasets of PBMC cells
* Taken from "Systematic comparative analysis of single cell RNA-sequencing methods" `r knitcitations::citet("10.1186/s13059-019-1863-4")`

## Project-specific parameters
This code chunk contains all parameters that are set specifically for the project. 
```{r project_parameters}
param = list()

# Project ID
param$project_id = "pbmc"

# Input data path
param$path_data = data.frame(name=c("pbmc_10x","pbmc_smartseq2"),
                             type=c("10x","smartseq2"),
                             path=c("test_datasets/10x_SmartSeq2_pbmc_GSE132044/counts/10x/", "test_datasets/10x_SmartSeq2_pbmc_GSE132044/counts/smartseq2/counts_table.tsv.gz"),  
                             stats=c(NA, NA))

# Output directory
param$path_out = "test_datasets/10x_SmartSeq2_pbmc_GSE132044/results/"

# Marker genes based on literature, translated to Ensembl IDs
# xlsx file, one list per column, first row as header and Ensembl IDs below
# Set to NULL if no known marker genes should be plotted
param$file_known_markers = "test_datasets/10x_pbmc_1k_healthyDonor_v3Chemistry/known_markers.xlsx"

# Annotation via biomaRt
param$mart_dataset = "hsapiens_gene_ensembl"
param$annot_version = 98
param$annot_main = c(ensembl="ensembl_gene_id", symbol="external_gene_name", entrez="entrezgene_accession")
param$file_annot = NULL
param$mart_attributes = c(param$annot_main, 
                          c("chromosome_name", "start_position", "end_position", 
                            "percentage_gene_gc_content", "gene_biotype", "strand", "description"))
param$biomart_mirror = NULL

# Prefix of mitochondrial genes 
param$mt = "^MT-"

# Filters
param$cell_filter = list(nFeature_RNA=c(200, NA), percent_mt=c(NA, 20))
param$feature_filter = list(min_counts=1, min_cells=3) # feature has to be found by at least one count in one cell

# Samples to drop 
# Cells from these samples will be dropped after initial QC
# Example: param$samples_to_drop = c("pbmc_smartseq2.NC", "pbmc_smartseq2.RNA"), 
#   where "smartseq2" is the name of the dataset (see path_data), and "NC" and "RNA" are the names of the samples
param$samples_to_drop = c() 

# Drop samples with too few cells
param$samples_min_cells = 10

# Whether or not to remove cell cycle effects
param$cc_remove = FALSE

# Should all cell cycle effects be removed, or only the difference between profilerating cells (G2M and S phase)?
# Read https://satijalab.org/seurat/v3.1/cell_cycle_vignette.html, for an explanation
param$cc_remove_all = FALSE

# Whether or not to re-score cell cycle effects after data
#   from different samples have been merged 
param$cc_rescore_after_merge = TRUE

# Additional (unwanted) variables that will be regressed out for visualisation and clustering
param$vars_to_regress = c()

# Additional (unwanted) variables to be included in the statistical tests
param$latent_vars = c()

# When there are multiple datasets, how to integrate them:
#   - method:
#     - single: Automatically default when there is only one dataset after filtering. No integration is needed.
#     - merge: Just merge them since no integration is needed (e.g. samples were multiplexed on the same chip)
#     - standard: Anchors are computed for all pairs of datasets. This will give all datasets the same weight during dataset integration but can be computationally intensive.
#     - reference: One dataset is used as reference and anchors are computed for all other datasets. Less accurate but computationally faster. 
#     - reciprocal: Anchors are computed in PCA space instead of the data. Even less accurate but for very big datasets.
#
#   - reference_dataset: When using method "reference", which dataset is the reference? Can be numeric or name of the dataset.
#   - dimensions: Number of dimensions to consider for integration
param$integrate_samples = list(method="standard", reference_dataset=1, dimensions=30)

# Which normalisation should be used for analysis: RNA or SCT?
param$norm = "RNA"

# The number of PCs to use; adjust this parameter based on the Elbowplot 
param$pc_n = 10

# Resolution of clusters; low values will lead to fewer clusters of cells 
param$cluster_resolution=0.5

# Thresholds to define differentially expressed genes 
param$padj = 0.05
param$log2FC = log2(2)

# P-value threshold for functional enrichment
param$p_enrichr = 0.05

# Enrichr databases of interest
param$enrichr_dbs = c("GO_Molecular_Function_2018", "GO_Biological_Process_2018", "GO_Cellular_Component_2018")

# Main colour(s) to use for plots
param$col = "palevioletred"

# Colour palette and colours used for samples
param$col_palette_samples = "ggsci::pal_jama"

# Colour palette and colours used for cluster
param$col_palette_clusters = "ggsci::pal_startrek"

# Sample data to at most n cells per dataset/sample (mainly for tests); set to NULL to deactivate
param$downsample_cells_n = NULL

# Path to git repository
param$path_to_git = "."
```

```{r initial_checks}
# Git directory and files to source must be done first, then all helper functions can be sourced
git_files_to_source = c("R/functions_io.R",
              "R/functions_plotting.R",
              "R/functions_analysis.R",
              "R/functions_degs.R",
              "R/functions_util.R")
git_files_to_source = paste(param$path_to_git, git_files_to_source, sep="/")
file_exists = purrr::map_lgl(git_files_to_source, file.exists)
if (any(!file_exists)) stop(paste("The following files could not be found:",paste(git_files_to_source[!file_exists], collapse=", "), ". Please check the git directory at '", param$path_to_git, "'.!"))
invisible(purrr::map(git_files_to_source, source))

# Set output hooks
knitr::knit_hooks$set(message=format_message, warning=format_warning)

# Do checks
error_messages = c()

# Check installed packages
error_messages = c(error_messages, check_installed_packages())
# Check python
error_messages = c(error_messages, check_python())
# Check parameters
error_messages = c(error_messages, check_parameters(param))
# Check enrichR
error_messages = c(error_messages, check_enrichr(param$enrichr_dbs))
# Check ensembl
error_messages = c(error_messages, check_ensembl(biomart="ensembl", 
                                                 dataset=param$mart_dataset, 
                                                 mirror=param$biomart_mirror, 
                                                 version=param$annot_version,
                                                 attributes=param$mart_attributes))
```

```{r initial_checks_failed, eval=length(error_messages)>0, include=length(error_messages)>0}
# Now format collected error messages as error boxes, print and exit
# Note: asis_output prints a content as is; knit_exist toggles knitr to exit after the current chunk
error_message_blocks = purrr::map(error_messages, format_error) %>% paste(collapse="")
knitr::knit_exit()
knitr::asis_output(error_message_blocks)
```


```{r preparation}
# Create output directory
if (!file.exists(param$path_out)) dir.create(param$path_out, recursive=TRUE, showWarnings=FALSE)
```

# Read data
## Read and print mapping statistics
We begin by printing mapping statistics that have been produced prior to this workflow. 
```{r mapping_stats, message=TRUE}
# Are statistics provided?
if (!all(is.na(param$path_data$stats))) { 
  
  # Loop through all samples and read mapping stats
  mapping_stats_list = list()
  for (i in 1:nrow(param$path_data)) {  
    if (!is.na(param$path_data$stats[i])) { 
      mapping_stats_list[[param$path_data$name[i]]] = read.delim(param$path_data$stats[i], 
                                                                 sep=",", header=FALSE, check.names=FALSE) %>%
        t() %>% as.data.frame()
    } 
  }
  
  # Join all mapping stats tables
  mapping_stats = mapping_stats_list %>% purrr::reduce(dplyr::full_join, by="V1")
  rownames(mapping_stats) = mapping_stats[["V1"]]
  mapping_stats = mapping_stats %>% dplyr::select(-V1)
  colnames(mapping_stats) = names(mapping_stats_list)
 
  # Print table to HTML 
  knitr::kable(mapping_stats, align="l", caption="Mapping statistics") %>% 
  kableExtra::kable_styling(bootstrap_options=c("striped", "hover"))
 
} else { 
  message("Mapping statistics cannot be shown. No valid file provided.")
}
```

## Read gene annotation
If not provided already, we read gene annotation from Ensembl and write the resulting table to file. We generate several dictionaries to translate between Ensembl IDs, gene symbols, Entrez Ids, and Seurat rownames. 
```{r read_annotation}
# If not provided by user, save annotation in the path_out directory
if (is.null(param$file_annot)) {
  param$file_annot = file.path(param$path_out, paste0(param$mart_dataset, ".v", param$annot_version, ".annot.txt"))
}

# Read annotation from csv or from Ensembl and a tab separated txt will be created
if (file.exists(param$file_annot)) {
  annot_ensembl = read.delim(param$file_annot)
} else {
  annot_mart = suppressWarnings(GetBiomaRt(biomart="ensembl", 
                                           dataset=param$mart_dataset, 
                                           mirror=param$biomart_mirror, 
                                           version=param$annot_version))
  annot_ensembl = biomaRt::getBM(mart=annot_mart, attributes=param$mart_attributes)
  write.table(annot_ensembl, file=param$file_annot, sep='\t', col.names=TRUE, row.names=FALSE, append=FALSE)
  message("Gene annotation file was created at: ", param$file_annot)
  # Note: depending on the attributes, there might be more than one row per gene
}

# Double-check if we got all required annotation, in case annotation file was read
check_annot_main = all(param$annot_main %in% colnames(annot_ensembl))
if (!check_annot_main) {
  stop("The annotation table misses at least one of the following columns: ", paste(param$annot_main, collapse=", "))
}

# Create translation tables
ensembl = param$annot_main["ensembl"]
symbol = param$annot_main["symbol"]
entrez = param$annot_main["entrez"]

# Ensembl id to gene symbol
ensembl_to_symbol = unique(annot_ensembl[, c(ensembl, symbol)])
ensembl_to_symbol = setNames(ensembl_to_symbol[, symbol], ensembl_to_symbol[, ensembl])

# Ensembl id to seurat-compatible unique rowname
ensembl_to_seurat_rowname = unique(annot_ensembl[, c(ensembl, symbol)])
ensembl_to_seurat_rowname[, symbol] = make.unique(gsub(pattern="_", replacement="-", x=ensembl_to_seurat_rowname[, symbol], fixed=TRUE))
ensembl_to_seurat_rowname = setNames(ensembl_to_seurat_rowname[, symbol], ensembl_to_seurat_rowname[, ensembl])

# Seurat-compatible unique rowname to ensembl id
seurat_rowname_to_ensembl = setNames(names(ensembl_to_seurat_rowname), ensembl_to_seurat_rowname)

# Gene symbol to ensembl id: named LIST to account for genes where one symbol translates to multiple Ensembl IDs
symbol_to_ensembl_df = unique(annot_ensembl[, c(ensembl, symbol)])
symbol_to_ensembl = split(symbol_to_ensembl_df[, ensembl], symbol_to_ensembl_df[, symbol])

# Gene symbol to (seurat compatible unique) gene symbol: named LIST to account for genes with multiple names
symbol_to_seurat_rowname = unique(annot_ensembl[, c(ensembl, symbol)])
symbol_to_seurat_rowname$seurat_rowname = ensembl_to_seurat_rowname[symbol_to_seurat_rowname[, ensembl]]
symbol_to_seurat_rowname = split(symbol_to_seurat_rowname$seurat_rowname, symbol_to_seurat_rowname[, symbol])

# Ensembl to Entrez
ensembl_to_entrez = unique(annot_ensembl[, c(ensembl, entrez)])
ensembl_to_entrez[, entrez] = ifelse(nchar(ensembl_to_entrez[, entrez]) == 0, NA, ensembl_to_entrez[, entrez])
ensembl_to_entrez = split(ensembl_to_entrez[, entrez], ensembl_to_entrez[, ensembl])

# Seurat-compatible unique rowname to Entrez
seurat_rowname_to_ensembl_match = match(seurat_rowname_to_ensembl, names(ensembl_to_entrez))
names(seurat_rowname_to_ensembl_match) = names(seurat_rowname_to_ensembl)
seurat_rowname_to_entrez = purrr::map(seurat_rowname_to_ensembl_match, function(i) {unname(ensembl_to_entrez[[i]])})

# Entrez IDs is duplicating Ensembl IDs in annot_ensembl
# Therefore, we remove Entrez IDs from the annotation table, after generating all required translation tables
# Set rownames of annotation table to Ensembl identifiers
annot_ensembl = annot_ensembl[, -match(entrez, colnames(annot_ensembl))] %>% unique() %>% as.data.frame()
rownames(annot_ensembl) = annot_ensembl[, ensembl]
```

```{r cc_genes_translate}
# Use biomart to translate human cell cycle genes to the species of interest and save them in a file
cc_genes_marker_file = paste0(param$path_out, "/cell_cycle_markers.xlsx")

if (file.exists(cc_genes_marker_file)) {
  # Load from file
  genes_s = openxlsx::read.xlsx(cc_genes_marker_file, sheet=1)
  genes_g2m = openxlsx::read.xlsx(cc_genes_marker_file, sheet=2)
} else {
  # Obtain from Ensembl
  # Note: both mart objects must point to the same mirror for biomarT::getLDS to work
  mart_human = suppressWarnings(GetBiomaRt(biomart="ensembl", 
                                           dataset="hsapiens_gene_ensembl", 
                                           mirror=param$biomart_mirror, 
                                           version=param$annot_version))
  mart_myspecies = suppressWarnings(GetBiomaRt(biomart="ensembl", 
                                               dataset=param$mart_dataset, 
                                               mirror=GetBiomaRtMirror(mart_human), 
                                               version=param$annot_version)) 
  
  # S phase marker
  genes_s = biomaRt::getLDS(attributes=c("ensembl_gene_id", "external_gene_name"), 
                          filters="external_gene_name", 
                          values=Seurat::cc.genes.updated.2019$s.genes, 
                          mart=mart_human, 
                          attributesL=c("ensembl_gene_id", "external_gene_name"), 
                          martL=mart_myspecies, 
                          uniqueRows=TRUE)
  colnames(genes_s) = c("Human_ensembl_id", "Human_gene_name", "Species_ensembl_id", "Species_gene_name")
  
  # G2/M marker
  genes_g2m = biomaRt::getLDS(attributes=c("ensembl_gene_id", "external_gene_name"), 
                            filters="external_gene_name", 
                            values=Seurat::cc.genes.updated.2019$g2m.genes, 
                            mart=mart_human, 
                            attributesL=c("ensembl_gene_id", "external_gene_name"), 
                            martL=mart_myspecies, 
                            uniqueRows=TRUE)
  colnames(genes_g2m) = c("Human_ensembl_id", "Human_gene_name", "Species_ensembl_id", "Species_gene_name")
  
  # Write to file
  openxlsx::write.xlsx(list(S_phase=genes_s,G2M_phase=genes_g2m),file=cc_genes_marker_file)
}

# Convert Ensembl ID to Seurat-compatible unique rowname
genes_s = data.frame(Human_gene_name=genes_s$Human_gene_name, Species_gene_name=unname(ensembl_to_seurat_rowname[genes_s$Species_ensembl_id]))
genes_g2m = data.frame(Human_gene_name=genes_g2m$Human_gene_name, Species_gene_name=unname(ensembl_to_seurat_rowname[genes_g2m$Species_ensembl_id]))
```

## Read scRNA-seq data
We next read the scRNA-seq dataset(s) into Seurat. 
```{r read_datasets}
# List of Seurat objects
sc = list()

datasets = param$path_data
for (i in seq(nrow(datasets))) {
  name = datasets[i,"name"]
  type = datasets[i,"type"]
  path = datasets[i,"path"]
  
  # Read 10X or smartseq2
  if (type == "10x") {
    
    # Read 10X sparse matrix into a Seurat object
    sc[[name]] = ReadSparseMatrix(path, 
                                  project=name, 
                                  row_name_column=1, 
                                  convert_row_names=ensembl_to_seurat_rowname)
    
  } else if (type == "smartseq2") {
    
    # Read counts table into a Seurat object
    sc = c(sc, ReadCountsTable(path, project=name, row_name_column=1, convert_row_names=ensembl_to_seurat_rowname, parse_plate_information=TRUE, return_samples_as_datasets=TRUE))
  } 
}

# Make cell names unique
sc = purrr::map(list_indices(sc), function(i){
  cell_names = gsub("-\\d+", "", colnames(sc[[i]]))
  Seurat::RenameCells(sc[[i]], new.names=paste(cell_names, i, sep="-"))
})

# Set up colors for samples
sample_names = purrr::flatten_chr(purrr::map(sc, function(s){ unique(as.character(s[[]][["orig.ident"]])) }))
param$col_samples = GenerateColours(num_colours=length(sample_names), palette=param$col_palette_samples)
names(param$col_samples) = sample_names

# Downsample cells if requested
if (!is.null(param$downsample_cells_n)) {
  sc = purrr::map(sc, function(s) {
    cells = colnames(s)
    return(subset(s, cells=sample(cells, min(param$downsample_cells_n, length(cells)))))
  })
  
  message("The dataset has been downsampled to ", param$downsample_cells_n, " cells.")
}

sc
```

The following first table shows metadata (columns) of the first 5 cells (rows). These metadata provide additional information about the cells in the dataset, such as the sample a cell belongs to ("orig.ident"), or the above mentioned number of unique genes detected ("nFeature"). The second table shows metadata (columns) of the first 5 genes (rows), for example the number of cells with at least 1 count for the gene ("num_cells_expr"), and the number of cells with at least as many counts as set in the parameter filter section ("num_cells_expr_threshold"). 

```{r metadata}
# Combine cell metadata of the Seurat objects into one big metadata
sc_cell_metadata = suppressWarnings(purrr::map_dfr(sc, function(s){ s[[]] }) %>% as.data.frame())

# Print cell metadata
knitr::kable(head(sc_cell_metadata), align="l", caption="Cell metadata, top 5 rows") %>%
  kableExtra::kable_styling(bootstrap_options = c("striped", "hover"))  %>% 
  kableExtra::scroll_box(width="100%")

# Print gene metadata
knitr::kable(head(sc[[1]][["RNA"]][[]], 5), align="l", caption="Feature metadata, top 5 rows (only first dataset shown)") %>% 
  kableExtra::kable_styling(bootstrap_options = c("striped", "hover"))  %>% 
  kableExtra::scroll_box(width="100%")
```

# Pre-processing
## Quality control 
We start the analysis by removing unwanted cells from the dataset(s). Three commonly used QC metrics include the number of unique genes detected in each cell ("nFeature_RNA"), the total number of molecules detected in each cell ("nCount_RNA"), and the percentage of counts that map to the mitochrondrial genome ("percent_mt"). If ERCC spike-in controls were used, the percentage of counts mapping to them is also shown ("percent_ercc").

```{r qc_criteria_create}
# If filters were specified globally (i.e. not by sample), this chunk will copy them for each sample such that downstream filtering can work by sample
param$cell_filter = purrr::map(list_names(sc), function(s) {
  if (s %in% names(param$cell_filter)) {
    return(param$cell_filter[[s]])
  } else {
    return(param$cell_filter)
  }
})

param$feature_filter = purrr::map(list_names(sc), function(s) {
  if (s %in% names(param$feature_filter)) {
    return(param$feature_filter[[s]])
  } else {
    return(param$feature_filter)
  }
})
```

```{r qc_calculate_cells}
# Calculate percentage of counts in mitochondrial genes for each Seurat object
sc = purrr::map(sc, Seurat::PercentageFeatureSet, pattern=param$mt, col.name="percent_mt", assay="RNA")

# Calculate percentage of counts in ERCC for each Seurat object (if assay is available)
sc = purrr::map(sc, function(s) {
  if ("ERCC" %in% Seurat::Assays(s)) s$percent_ercc = s$nCount_ERCC/(s$nCount_ERCC + s$nCount_RNA)*100
  return(s)
  })

# Combine (again) cell metadata of the Seurat objects into one big metadata, this time including mt and ercc 
sc_cell_metadata = suppressWarnings(purrr::map_dfr(sc, function(s){ s[[]] }) %>% as.data.frame())
```

```{r qc_calculate_features}
# Only RNA assay at the moment
# counts_median uses sapply on the counts matrix, which converts the sparse matrix into a normal matrix
#   This might have to be adapted in future (Sparse Matrix Apply Function)
sc = purrr::map(list_names(sc), function(n) {
  # Calculate percentage of counts per gene in a cell
  counts_rna = Seurat::GetAssayData(sc[[n]], slot="counts", assay="RNA")
  total_counts = sc[[n]][["nCount_RNA", drop=TRUE]]
  counts_rna_perc = Matrix::t(Matrix::t(counts_rna)/total_counts)*100

  # Calculate feature filters
  num_cells_expr = Matrix::rowSums(counts_rna >= 1)
  num_cells_expr_threshold = Matrix::rowSums(counts_rna >= param$feature_filter[[n]][["min_counts"]])
  
  # Calculate median of counts_rna_perc per gene 
  counts_median = apply(counts_rna_perc, 1, median)
  
  # Add all QC measures as metadata
  sc[[n]][["RNA"]] = Seurat::AddMetaData(sc[[n]][["RNA"]], data.frame(num_cells_expr, num_cells_expr_threshold, counts_median))
  return(sc[[n]])
})
```

```{r qc_plot_cells, fig.height=10}
# Plot QC metrics for cells
cell_qc_features = c("nFeature_RNA", "nCount_RNA", "percent_mt")
if ("percent_ercc" %in% colnames(sc_cell_metadata)) cell_qc_features = c(cell_qc_features, "percent_ercc")
cell_qc_features = values_to_names(cell_qc_features)

p_list = list()
for (i in names(cell_qc_features)) {
  p_list[[i]]= ggplot(sc_cell_metadata, aes_string(x="orig.ident", y=i, fill="orig.ident")) +
    geom_violin(scale="width") + 
    AddStyle(title=i, legend_position="none", fill=param$col_samples, xlab="") + 
    theme(axis.text.x=element_text(angle=45, hjust=1))

  # Creates a table with min/max values for filter i for each dataset
  cell_filter_for_plot = purrr::map_dfr(names(param$cell_filter), function(n) {
    # If filter i in cell filter of the dataset, then create dataframe with columns orig.ident, threshold and value
    if (i %in% names(param$cell_filter[[n]])){
      data.frame(orig.ident=n, threshold=c("min", "max"), value=param$cell_filter[[n]][[i]], stringsAsFactors=FALSE)
    } 
  })
  
  # Add filters as segments to plot
  if (nrow(cell_filter_for_plot)>0) {
    # Remove entries that are NA
    cell_filter_for_plot = cell_filter_for_plot %>% dplyr::filter(!is.na(value))
    p_list[[i]] = p_list[[i]] + geom_segment(data=cell_filter_for_plot, 
                                             aes(x=as.integer(as.factor(orig.ident))-0.5, 
                                                 xend=as.integer(as.factor(orig.ident))+0.5, 
                                                 y=value, yend=value), 
                                             lty=2, col="firebrick")
  }
}
p = patchwork::wrap_plots(p_list, ncol=2) + patchwork::plot_annotation("Distribution of feature values") 
p
```

```{r qc_plot_correlation}
# Correlate QC metrics for cells
p_list = list()
p_list[[1]] = ggplot(sc_cell_metadata, aes_string(x=cell_qc_features[2], y=cell_qc_features[1], colour="orig.ident")) +
  geom_point() + 
  AddStyle(col=param$col_samples)
p_list[[2]] = ggplot(sc_cell_metadata, aes_string(x=cell_qc_features[3], y=cell_qc_features[1], colour="orig.ident")) +
  geom_point() + 
  AddStyle(col=param$col_samples)
p = patchwork::wrap_plots(p_list, ncol=2) + patchwork::plot_annotation("Features plotted against each other")

if (length(sc)==1) {
  p = p & theme(legend.position="bottom")
} else {
  p = p + patchwork::plot_layout(guides = "collect") & theme(legend.position="bottom")
}
p
```

## Genes with highest expression
We next investigate whether there are individual genes that are represented by an unusually high number of counts. For each cell, we first calculate the percentage of counts per gene. Subsequently, for each gene, we calculate the median value of these percentages. Genes with the highest median percentage of counts are plotted below. 
```{r highest_expression}
# Plot only samples that we intend to keep 
sc_names = names(sc)[!(names(sc) %in% param$samples_to_drop)]
genes_highestExpr = lapply(sc_names, function(i) {
  idx = sc[[i]][["RNA"]][["counts_median"]] %>% order(decreasing=TRUE) %>% head(n=10)
  return(rownames(sc[[i]][["RNA"]][[]])[idx])
  }) %>%
  unlist() %>%
  unique()

genes_highestExpr_counts = purrr::map_dfc(sc[sc_names], .f=function(s) s[["RNA"]][["counts_median"]][genes_highestExpr,]) 
genes_highestExpr_counts$gene = genes_highestExpr

genes_highestExpr_counts = genes_highestExpr_counts %>% tidyr::pivot_longer(cols=all_of(sc_names))
genes_highestExpr_counts$name = factor(genes_highestExpr_counts$name, levels=sc_names)

col =  GenerateColours(num_colours=length(genes_highestExpr), palette="ggsci::pal_simpsons")
ggplot(genes_highestExpr_counts, aes(x=name, y=value, col=gene, group=gene)) + 
  geom_point() + 
  geom_line() + 
  AddStyle(title="Top 10 highest expressed genes per sample, added into one list", 
           xlab="Sample", ylab="Median % of raw counts\n per gene in a cell", 
           legend_position="bottom", 
           col=col)
```

## Filtering
Cells and genes are filtered based on the following thresholds: 
```{r filter_print_cutoffs}
cell_filter_list = param$cell_filter %>% unlist(recursive=FALSE)
cell_filter_tbl = cell_filter_list %>% purrr::reduce(rbind) %>% as.data.frame()
rownames(cell_filter_tbl) = names(cell_filter_list)
colnames(cell_filter_tbl) = c("Min", "Max")

feature_filter_list = param$feature_filter %>% unlist(recursive=FALSE)
feature_filter_tbl = feature_filter_list %>% purrr::reduce(rbind) %>% as.data.frame()
rownames(feature_filter_tbl) = names(feature_filter_list)
colnames(feature_filter_tbl) = "n"

knitr::kable(cell_filter_tbl, align="l", caption="Filters applied to cells") %>% 
  kableExtra::kable_styling(bootstrap_options = c("striped", "hover"))
  
knitr::kable(feature_filter_tbl, align="l", caption="Filters applied to genes") %>% 
  kableExtra::kable_styling(bootstrap_options = c("striped", "hover"))
```

The number of excluded cells and features is as follows: 
```{r filter_cells}
# Iterate over datasets and filters
# Record a cell if it does not pass the filter
# Also record a cell if it belongs to a sample that should be dropped
sc_cells_to_exclude  = purrr::map(list_names(sc), function(n) { 
  filter_result = purrr::map(list_names(param$cell_filter[[n]]), function(f) {
    filter = param$cell_filter[[n]][[f]]
    if (is.numeric(filter)) {
      if (is.na(filter[1])) filter[1] = -Inf # Minimum
      if (is.na(filter[2])) filter[2] = Inf  # Maximum 
      idx_exclude = sc[[n]][[f, drop=TRUE]] < filter[1] | sc[[n]][[f, drop=TRUE]] > filter[2]
      return(names(which(idx_exclude)))
    } else if (is.character(filter)) { 
      return(names(which(sc[[n]][[f, drop=TRUE]] %in% filter)))
    }
  })

  # Samples to drop
  if (length(param$samples_to_drop)>0 && n %in% param$samples_to_drop) {
    filter_result[["samples_to_drop"]] = colnames(sc[[n]])
  }
  
  # Minimum number of cells for a sample to keep
  if (!is.null(param$samples_min_cells) && param$samples_min_cells > 0 && ncol(sc[[n]]) < param$samples_min_cells) {
    filter_result[["samples_min_cells"]] = colnames(sc[[n]])
  }
  return(filter_result)
})

# Summarise
sc_cells_to_exclude_summary = purrr::map_dfr(sc_cells_to_exclude, function(s) {
  return(as.data.frame(purrr::map(s,length))) 
  })
rownames(sc_cells_to_exclude_summary) = names(sc_cells_to_exclude)
knitr::kable(sc_cells_to_exclude_summary, align="l", caption="Number of excluded cells") %>% 
  kableExtra::kable_styling(bootstrap_options = c("striped", "hover")) 

# Now filter, drop the respective colours and adjust integration method
sc = purrr::map(list_names(sc), function(n) {
  cells_to_keep = Cells(sc[[n]])
  cells_to_keep = cells_to_keep[!cells_to_keep %in% purrr::flatten_chr(sc_cells_to_exclude[[n]])]
  if (length(cells_to_keep)==0) return(NULL)
  else return(subset(sc[[n]], cells=cells_to_keep))
}) %>% purrr::discard(is.null)

if (length(sc)==1) param$integrate_samples[["method"]] = "single"
```

```{r filter_features}
# Only RNA assay at the moment

# Iterate over datasets and record a feature if it does not pass the filter
sc_features_to_exclude = purrr::map(list_names(sc), function(n) {
  if (length(Cells(sc[[n]])) < param$feature_filter[[n]][["min_cells"]]) return(list())
  else return(names(which(sc[[n]][["RNA"]][["num_cells_expr_threshold", drop=TRUE]] < param$feature_filter[[n]][["min_cells"]])))
})

# Summarise
sc_features_to_exclude_summary = purrr::map(sc_features_to_exclude, length) %>% 
  t() %>% as.data.frame() 
rownames(sc_features_to_exclude_summary) = c("Genes")
knitr::kable(sc_features_to_exclude_summary, align="l", caption="Number of excluded genes") %>% 
  kableExtra::kable_styling(bootstrap_options = c("striped", "hover"))

# Now filter
sc = purrr::map(list_names(sc), function(n) {
  assay_names = Seurat::Assays(sc[[n]])
  features_to_keep = purrr::map(values_to_names(assay_names), function(a) {
    features = rownames(sc[[n]][[a]])
    keep = features[!features %in% sc_features_to_exclude[[n]]]
    return(keep)
  })
  return(subset(sc[[n]], features=purrr::flatten_chr(features_to_keep)))
})
```

After filtering, the size of the Seurat object is: 
```{r filter_size_after}
sc
```

## Normalisation, scaling, variable genes, and cell cycle scoring
In this section, we subsequently run a series of Seurat functions for each provided sample:  
1. We start by running a __standard log normalisation__, where counts for each cell are divided by the total counts for that cell and multiplied by 10,000. This is then natural-log transformed.   
2. We assign __cell cycle scores__ to each cell based on its normalised expression of G2/M and S phase markers. These scores are visualised in a separate section further below. If specified in the above parameter section, cell cycle effects are removed during scaling (step 3). 
3. Dependent on the normalisation of your choice, we either   
3a. Run standard functions to select __variable genes__, and __scale__ normalised gene counts. For downstream analysis it is beneficial to focus on genes that exhibit high cell-to-cell variation, that is they are highly expressed in some cells and lowly in others. To be able to compare normalised gene counts between genes, gene counts are further scaled to have zero mean and unit variance (z-score).   
3b. Run __SCTransform__, a new and more sophisticated normalisation method that replaces the previous functions (__normalisation, variable genes and scaling__). 

Note that removing all signal associated to cell cycle can negatively impact downstream analysis. For example, in differentiating processes, stem cells are quiescent and differentiated cells are proliferating (or vice versa), and removing all cell cycle effects can blur the distinction between these cells. As an alternative, we can remove the difference between G2M and S phase scores. This way, signals separating non-cycling and cycling cells will be maintained, while differences amongst proliferating cells will be removed. For a more detailed explanation, see the cell cycle vignette for Seurat `r knitcitations::citep("https://satijalab.org/seurat/v3.1/cell_cycle_vignette.html")`. Cell cycle effect removed for this report: `r param$cc_remove`; _all_ cell cycle effects removed for this report: `r param$cc_remove_all`.   

While raw data is typically used for statistical tests such as finding marker genes, normalised data is mainly used for visualising gene expression values. Scaled data include variable genes only, potentially without cell cycle effects, and are mainly used to determine the structure of the dataset(s) with Principal Component Analysis, and indirectly to cluster and visualise cells in 2D space. 
```{r part1_normalisation}
# Normalise data the original way
#   This is required to score cell cycle
#   https://github.com/satijalab/seurat/issues/1679
sc = purrr::map(sc, Seurat::NormalizeData, normalization.method = "LogNormalize", scale.factor=10000, verbose=FALSE)
```

```{r part2_cc_scores}
# Determine cell cycle effect per sample 
sc = purrr::map(list_names(sc), function(n) {
  sc[[n]] = cc_scoring(sc=sc[[n]], genes_s=genes_s[,2], genes_g2m=genes_g2m[,2], name=n)
  if (all(is.na(sc[[n]][["S.Score"]])) & all(is.na(sc[[n]][["G2M.Score"]]))) param$cc_remove=FALSE
  return(sc[[n]])
})

# If cell cycle effects should be removed, we first score cells 
# The effect is then removed in the following chunk 
if (param$cc_remove) {
# Add to vars that need to regressed out during normalisation
  if (param$cc_remove_all) {
    # Remove all signal associated to cell cycle
    param$vars_to_regress = unique(c(param$vars_to_regress, "S.Score", "G2M.Score"))
    param$latent_vars = unique(c(param$latent_vars, "S.Score", "G2M.Score"))
  } else {
    # Don't remove the difference between cycling and non-cycling cells 
    param$vars_to_regress = unique(c(param$vars_to_regress, "CC.Difference"))
    param$latent_vars = unique(c(param$latent_vars, "CC.Difference"))
  }  
}
```

```{r part3_normalisation, results="hide", warning=FALSE}
if (param$norm == "RNA") { 
  # Find variable features from normalised data (unaffected by scaling)
  sc = purrr::map(sc, Seurat::FindVariableFeatures, selection.method = "vst", nfeatures = 3000, verbose=FALSE)
  
  # Scale 
  # Note: For a single dataset where no integration is needed, all features can already be scaled here. 
  #   Otherwise, it is enough to scale variable features only and scaling of all features will be done later.
  sc = purrr::map(sc, function(s) { 
    Seurat::ScaleData(s, 
                      features=ifelse(param$integrate_samples[["method"]]=="single", rownames(s[["RNA"]]), VariableFeatures(s)), 
                      vars.to.regress=param$vars_to_regress, 
                      verbose=FALSE) 
  })
  
} else if (param$norm == "SCT") {
  # Run SCTransform
  #
  # This is a new normalisation method that replaces previous Seurat functions 'NormalizeData', 'FindVariableFeatures', and 'ScaleData'. 
  # vignette: https://satijalab.org/seurat/v3.0/sctransform_vignette.html
  # paper: https://www.biorxiv.org/content/10.1101/576827v2
  # Normalised data end up here: sc@assays$SCT@data
  # Note: For a single dataset where no integration is needed, all features can already be scaled here. 
  #   Otherwise, it is enough to scale only the variable features.
  # Note: It is not guaranteed that all genes are successfully normalised with SCTransform. 
  #   Consequently, some genes might be missing from the SCT assay. 
  #   See: https://github.com/ChristophH/sctransform/issues/27
  sc = purrr::map(list_names(sc), function(n) { 
    SCTransform(sc[[n]], 
                vars.to.regress=param$vars_to_regress, 
                min_cells=param$feature_filter[[n]][["min_cells"]], 
                verbose=FALSE, 
                return.only.var.genes=!(param$integrate_samples[["method"]]=="single")) 
  })
}
```

### Variable genes
Experience shows that 1,000-2,000 genes with the highest cell-to-cell variation are often sufficient to describe the global structure of a single cell dataset. For example, cell type-specific genes typically highly vary between cells. Housekeeping genes, on the other hand, are similarly expressed across cells and can be disregarded to differentiate between cells.   

To determine variable genes, we need to separate biological variability from technical variability. Technical variability arises especially for lowly expressed genes, where high variability corresponds to small absolute changes that we are not interested in. Here, we use the variance-stabilizing transformation (vst) method implemented in Seurat (`r knitcitations::citet("10.1186/s13059-019-1874-1")`. This method first models the technical variability as a relationship between mean gene expression and variance using local polynomial regression. The model is then used to calculate the expected variance based on the observed mean gene expression. The difference between the observed and expected variance is called residual variance and likely reflects biological variability. The top 3,000 variable genes are used for further analysis. 
```{r plot_variable_features_heights}
fig_height_vf = 5 * ceiling(length(names(sc))/2)
```

```{r plot_variable_features, warning=FALSE, fig.height=fig_height_vf}
p_list = purrr::map(list_names(sc), function(n) {
  top10 = head(Seurat::VariableFeatures(sc[[n]], assay=param$norm), 10)
  p = Seurat::VariableFeaturePlot(sc[[n]], 
                                  assay=param$norm, 
                                  selection.method=ifelse(param$norm=="RNA", "vst", "sct"), 
                                  col=c("grey", param$col)) + 
    AddStyle(title=n) + 
    theme(legend.position=c(0.2, 0.8), legend.background=element_rect(fill=alpha("white", 0.0)))
  p = LabelPoints(plot=p, points=top10, repel=TRUE, xnudge=0, ynudge=0)
  return(p)
})

p = patchwork::wrap_plots(p_list, ncol=2) + patchwork::plot_annotation("Variable genes")
p
```

## Combining multiple samples
```{r multi_dataset_integration_single, eval=(param$integrate_samples[["method"]]=="single"), include=(param$integrate_samples[["method"]]=="single")}
# Called when there is only a single sample and no integration needed
# Default assay is set automatically
if (param$integrate_samples[["method"]]=="single") {
  sc = sc[[1]]
  message("Your dataset contains 1 sample only. No merging/intregating required.")
}
```

```{r multi_dataset_integration_preparation, eval=(param$integrate_samples[["method"]]!="single"), include=(param$integrate_samples[["method"]]!="single"), results="asis"}
if (param$integrate_samples[["method"]]!="single") {
  
  # Feature meta-data is removed by Seurat merge entirely; save separately for each assay and add again afterwards
  assay_names = unique(purrr::flatten_chr(purrr::map(list_names(sc), function(n) { Assays(sc[[n]]) } )))
  
  # Loop through all assays and accumulate meta data
  feature_data_for_assay = purrr::map(values_to_names(assay_names), function(a) {
    # "feature_id", "feature_name", "feature_type" are accumulated for all assays and stored just once
    # This step is skipped for assays that do not contain all three types of feature information
    contains_neccessary_columns = purrr::map_lgl(list_names(sc), function(n) { 
      all(c("feature_id", "feature_name", "feature_type") %in% colnames(sc[[n]][[a]][[]])) 
      })

    if (all(contains_neccessary_columns)) {
      feature_id_name_type = purrr::map(sc, function(s) return(s[[a]][[c("feature_id", "feature_name", "feature_type")]]) )
      feature_id_name_type = purrr::reduce(feature_id_name_type, function(df_x, df_y) {
        new_rows = which(!rownames(df_y) %in% rownames(df_x))
        if (length(new_rows)>0) return(rbind(df_x, df_y[new_rows,]))
        else return(df_x)
      })
      feature_id_name_type$row_names = rownames(feature_id_name_type)
    } else {
      feature_id_name_type = NULL
    }
    
    # For all other meta-data, we prefix column names with the dataset
    other_feature_data = purrr::map(list_names(sc), function(n) {
      df = sc[[n]][[a]][[]]
      if (contains_neccessary_columns[[n]]) df = df %>% dplyr::select(-dplyr::one_of(c("feature_id", "feature_name", "feature_type"), c()))
      if (ncol(df) > 0) colnames(df) = paste(n, colnames(df), sep=".")
      df$row_names = rownames(df)
      return(df)
    })
    
    # Now join everything by row_names by full outer join
    if (!is.null(feature_id_name_type)) {
      feature_data = purrr::reduce(c(list(feature_id_name_type=feature_id_name_type), other_feature_data), dplyr::full_join, by="row_names")
    } else {
      feature_data = purrr::reduce(other_feature_data, dplyr::full_join, by="row_names")
    }
    rownames(feature_data) = feature_data$row_names
    feature_data$row_names = NULL
    
    return(feature_data)
  })
}
```

```{r multi_dataset_integration_merge, eval=(param$integrate_samples[["method"]]=="merge"), include=(param$integrate_samples[["method"]]=="merge")}
# Data for different samples can be merged if no integration is needed, 
#   for example, when samples were multiplexed on the same chip
if (param$integrate_samples[["method"]]=="merge") {
  sc = merge(x=sc[[1]], y=sc[2:length(sc)], project=param$project_id)

  # Re-score cell cycle effects after merge
  if (param$cc_rescore_after_merge) {
    sc = cc_scoring(sc=sc, genes_s=genes_s[,2], genes_g2m=genes_g2m[,2])
    if (all(is.na(sc[["S.Score"]])) & all(is.na(sc[["G2M.Score"]]))) param$cc_remove=FALSE
  }
  
  # (Re-)Run normalisation, variable features and scaling
  if (param$norm == "RNA") {
    # Find variable features in RNA assay
    sc = Seurat::FindVariableFeatures(sc, selection.method = "vst", nfeatures = 3000, verbose=FALSE)
   
    # Scale RNA assay
    # Note: Removing cell cycle effects in "RNA" scaled data can be very slow
    sc = Seurat::ScaleData(sc, features=rownames(sc[["RNA"]]), vars.to.regress=param$vars_to_regress, verbose=FALSE, assay="RNA")
  
  } else if (param$norm == "SCT") {
    # Rerun SCTransform
    min_cells_overall = max(purrr::map_int(param$feature_filter, function(f) as.integer(f[["min_cells"]])))
    sc = suppressWarnings(SCTransform(sc, 
                                      vars.to.regress=param$vars_to_regress, 
                                      min_cells=min_cells_overall, 
                                      verbose=FALSE, 
                                      return.only.var.genes=FALSE))
  }
  
  # Add feature metadata
  for (a in Seurat::Assays(sc)) {
    if (a %in% names(feature_data_for_assay)) {
      sc[[a]] = Seurat::AddMetaData(sc[[a]], feature_data_for_assay[[a]][rownames(sc[[a]]),, drop=FALSE])
    }
  }

  message("Data values for all samples have been merged. This means that data values have been concatenated, not integrated.")
  print(sc)
}
```

```{r multi_dataset_integration_standard, eval=(param$integrate_samples[["method"]]=="standard"), include=(param$integrate_samples[["method"]]=="standard"), warning=FALSE}
# Standard method for integrating multiple samples. 
#   Best performance but computationally intensive.
if (param$integrate_samples[["method"]]=="standard") {
  # Note "Assay names should only have numbers and letters: Warnung: Keys should be one or more alphanumeric characters followed by an underscore, setting key from rna_integrated_ to rnaintegrated_" (seurat/R/object.R)
  
  # The integration step will temporarily occupy a lot of memory. 
  #   However, R has problems with freeing unused memory.
  #   By wrapping the steps into a function, hopefully this works a bit better.
  run_standard_integration = function(sc_objs, ndims=30, vars_to_regress=c(), feature_filter=c(), verbose=FALSE, assay="RNA") {
    # How many neighbors to use when filtering anchors
    k.filter = min(200, min(sapply(sc_objs, ncol)))

    
    # Find integration anchors for assay RNA
    if (assay == "RNA") {
      integrate_RNA_anchors = Seurat::FindIntegrationAnchors(object.list=sc_objs, 
                                                             dims=1:ndims, 
                                                             anchor.features=3000, 
                                                             k.filter=k.filter,
                                                             verbose=verbose)
      sc_objs = Seurat::IntegrateData(integrate_RNA_anchors, 
                                      new.assay.name="RNAintegrated",
                                      dims=1:ndims, 
                                      verbose=verbose)
      # According to Seurat, we need to scale data again for "RNAintegrated", and "RNA"
      sc_objs = Seurat::ScaleData(sc_objs, 
                                  features=rownames(sc_objs[["RNAintegrated"]]), 
                                  vars.to.regress=vars_to_regress, 
                                  assay="RNAintegrated",
                                  verbose=verbose)
      DefaultAssay(sc_objs) = "RNA"
      sc_objs = Seurat::ScaleData(sc_objs, 
                                  features=rownames(sc_objs[["RNA"]]), 
                                  vars.to.regress=vars_to_regress, 
                                  assay="RNA",
                                  verbose=verbose)
      rm(integrate_RNA_anchors)

    } else if (assay == "SCT") {
      # Find integration anchors for assay SCT
      integrate_SCT_features = SelectIntegrationFeatures(object.list=sc_objs, 
                                                         nfeatures=3000,
                                                         verbose=verbose)
      sc_objs = PrepSCTIntegration(object.list=sc_objs, 
                                   anchor.features=integrate_SCT_features, 
                                   assay=rep("SCT",length(sc_objs)),
                                   verbose=verbose)
      integrate_SCT_anchors = FindIntegrationAnchors(object.list=sc_objs,
                                                     dims=1:ndims, 
                                                     normalization.method="SCT", 
                                                     anchor.features=integrate_SCT_features, 
                                                     k.filter=k.filter,
                                                     verbose=verbose)
      sc_objs = Seurat::IntegrateData(integrate_SCT_anchors, 
                                      new.assay.name="SCTintegrated",
                                      normalization.method="SCT", 
                                      dims=1:ndims, 
                                      verbose=verbose)
      # We need to re-run SCTransform for the "SCT" assay again, to normalise on the complete dataset
      DefaultAssay(sc_objs) = "SCT"
      min_cells_overall = max(purrr::map_int(feature_filter, function(f) as.integer(f[["min_cells"]])))
      sc_objs = SCTransform(sc_objs, 
                            vars.to.regress=vars_to_regress, 
                            min_cells=min_cells_overall, 
                            verbose=FALSE, 
                            return.only.var.genes=FALSE)
      rm(integrate_SCT_features, integrate_SCT_anchors)
    }
    
    # Call garbage collector to free memory (hope it helps)
    gc(verbose=verbose)
    return(sc_objs)
  }
  
  # call function
  sc = run_standard_integration(sc, ndims=param$integrate_samples[["dimensions"]], vars_to_regress=param$vars_to_regress, feature_filter=param$feature_filter, assay=param$norm)
  
  # Add feature metadata
  for (a in Seurat::Assays(sc)) {
    if (a %in% names(feature_data_for_assay)) {
      sc[[a]] = Seurat::AddMetaData(sc[[a]], feature_data_for_assay[[a]][rownames(sc[[a]]),, drop=FALSE])
    }
  }
  
  # Set default assay (will be the integrated version)
  DefaultAssay(sc) = paste0(param$norm, "integrated")  
  
  message("Data values for all samples have been integrated.")
  print(sc)
}
```

```{r multi_dataset_integration_reference, eval=(param$integrate_samples[["method"]]=="reference"), include=(param$integrate_samples[["method"]]=="reference")}
# Method uses one dataset as reference and all other datasets are integrated into this dataset. Faster but lower performance.
if (param$integrate_samples[["method"]]=="reference") {
   stop("Not yet implemented")
}
```

```{r multi_dataset_integration_reciprocal, eval=(param$integrate_samples[["method"]]=="reciprocal"), include=(param$integrate_samples[["method"]]=="reciprocal")}
# Method computes anchors in PCA space instead of the data. Even less accurate but for very big datasets.
if (param$integrate_samples[["method"]]=="reciprocal") {
   stop("Not yet implemented")
}
```

## Relative log expression {.tabset}
```{r plot_RLE_prep}
n_cells_rle_plot = min(100, sc[["orig.ident"]] %>% table() %>% min())

# Sample at most 100 cells per dataset and save their identity
cells_RLE_subset = sc[["orig.ident"]] %>% tibble::rownames_to_column() %>% 
  dplyr::group_by(orig.ident) %>% 
  dplyr::sample_n(size=n_cells_rle_plot) %>% 
  dplyr::select(rowname, orig.ident)
  
cells_RLE_sample = cells_RLE_subset %>% dplyr::pull(orig.ident)
cells_RLE_subset = cells_RLE_subset %>% dplyr::pull(rowname)
```

To better understand the efficiency of the applied normalisation procedures, we plot the relative log expression of genes in at most `r n_cells_rle_plot` randomly selected cells per sample before and after normalisation. This type of plot reveals unwanted variation in your data. The concept is taken from `r knitcitations::citet("10.1371/journal.pone.0191629")`. In brief, we remove variation between genes, leaving only variation between samples. If expression levels of most genes are similar in all cell types, sample heterogeneity is a sign of unwanted variation.

For each gene, we calculate its median expression across all cells, and then calculate the deviation from this median for each cell. For each cell, we plot the median expression (black), the interquartile range (lightgrey), whiskers defined as 1.5 times the interquartile range (darkgrey), and outliers (`r param$col_samples`). 

### Raw counts
```{r plot_RLE_raw}
# Get counts from assay RNA
data_RLE_raw = GetAssayData(subset(sc, cells=cells_RLE_subset), assay="RNA", slot="counts")

# Plot
p = PlotRLE(as.matrix(log2(data_RLE_raw + 1)), id=cells_RLE_sample, col=param$col_samples) + labs(title="log2(raw counts + 1)")
p
```

### Normalised data
Dependent on the context, this tab refers to different data:   

* Single sample: `r param$norm` normalisation of the single sample   
* Multiple samples that were merged: Combined `r param$norm` normalisation post merging of all samples   
* Multiple samples that were integrated: Separate `r param$norm` normalisation prior to integration of all samples   

```{r plot_RLE_norm}
# Get normalised data before integration
data_RLE_norm = GetAssayData(subset(sc, cells=cells_RLE_subset), assay=param$norm, slot="data")

# Plot
p = PlotRLE(as.matrix(data_RLE_norm), id=cells_RLE_sample, col=param$col_samples) + labs(title="Normalised data")
p 
```

### Integrated data
```{r plot_RLE_integrated}
if (! param$integrate_samples[["method"]] %in% c("single", "merge")) {
  # Get normalised data for integrated assays
  data_RLE_int = GetAssayData(subset(sc, cells=cells_RLE_subset), assay=paste0(param$norm, "integrated"), slot="data")

  # Plot
  p = PlotRLE(as.matrix(data_RLE_int), id=cells_RLE_sample, col=param$col_samples) + labs(title="Normalised integrated data")
  p
} else {
  message("No integrated data available.")
}
```
  
## Dimensionality reduction
A single-cell dataset of 20,000 genes and 5,000 cells has 20,000 dimensions. At this point of the analysis, we have already reduced the dimensionality of the dataset to 3,000 variable genes. The biological manifold however can be described by far fewer dimensions than the number of (variable) genes. Dimension reduction methods aim to find these dimensions. There are two general purposes for dimension reduction methods: to summarise a dataset, and to visualise a dataset. 

We use Principal Component Analysis (PCA) to summarise a dataset, overcoming noise and reducing the data to its essential components. Each principal component (PC) represents a "metafeature" that combines information across a correlated gene set. Later, we use Uniform Manifold Approximation and Projection (UMAP) to visualise the dataset, placing similar cells together in 2D space, see below. 

To decide how many PCs to include in downstream analyses, we visualize cells and genes that define the PCA.
```{r pca}
# Run PCA for default normalisation
sc = Seurat::RunPCA(sc, features=Seurat::VariableFeatures(object=sc), verbose=FALSE)

p_list = Seurat::VizDimLoadings(sc, dims=1:2, reduction="pca", col=param$col, combine=FALSE)
for (i in seq(p_list)) p_list[[i]] = p_list[[i]] + AddStyle()
p =  patchwork::wrap_plots(p_list, ncol = 2) + patchwork::plot_annotation("Top gene loadings of the first two PCs") 
p

p = Seurat::DimPlot(sc, reduction="pca", cols=param$col_samples) + 
  AddStyle(title="Cells arranged by the first two PCs", legend_position="bottom")
p

p = Seurat::DimHeatmap(sc, dims=1:1, cells=min(500, ncol(sc)), balanced=TRUE, fast=FALSE)
p
```

```{r pca_heatmaps, fig.height=20}
p = Seurat::DimHeatmap(sc, dims=1:20, cells=min(500, ncol(sc)), balanced=TRUE, fast=FALSE)
p
```

## Dimensionality of the dataset
We next need to decide how many PCs we want to use for our analyses. The following "Elbow plot" is designed to help us make an informed decision.  PCs are ranked based on the percentage of variance they explain. 

For the current dataset, `r param$pc_n` PCs were chosen. 
```{r dimensionality}
# More approximate technique used to reduce computation time
p = Seurat::ElbowPlot(sc, ndims=20) + 
  geom_vline(xintercept=param$pc_n + .5, col="firebrick", lty=2) + 
  AddStyle(title="Elbow plot") 
p
```

# Downstream analysis
## Clustering
Seurat's clustering method first constructs a graph structure, where nodes are cells and edges are drawn between cells with similar gene expression patterns. Technically speaking, Seurat first constructs a K-nearest neighbor (KNN) graph based on Euclidean distance in PCA space, and refines edge weights between cells based on the shared overlap in their local neighborhoods (Jaccard similarity). To partition the graph into highly interconnected parts, cells are iteratively grouped together using the Leiden algorithm. 
```{r clustering}
# Note: I changed the seed in ./lib/python3.6/site-packages/leidenalg/functions.py to 11 for reproducibility
# The number of clusters can be optimized by tuning 'resolution' -> based on feedback from the client whether or not clusters make sense

# Choose the number of PCs to use for clustering
sc = Seurat::FindNeighbors(sc, dims=1:param$pc_n, verbose=FALSE)

# Cluster using the Leiden algorithm
# Paper to Leiden algorithm: https://www.nature.com/articles/s41598-019-41695-z
# Seurat vignette suggests resolution parameter between 0.4-1.2 for datasets of about 3k cells
# Taken from documentation:
#   Method for running leiden (defaults to matrix which is fast for small datasets). Enable method = "igraph" to avoid casting large data to a dense matrix.
# Note Katrin: 
#   This is implemented as default recently and will be updated with a new Seurat release
#   https://github.com/satijalab/seurat/pull/3233
sc = Seurat::FindClusters(sc, resolution=param$cluster_resolution, algorithm=4, verbose=FALSE, method="igraph")

# Construct phylogenetic tree relating the 'average' cell from each cluster
sc = BuildClusterTree(sc, dims=1:param$pc_n, verbose=FALSE)

# Set up colors for clusters
cluster_names = levels(sc$seurat_clusters)
param$col_clusters = GenerateColours(num_colours=length(cluster_names), palette=param$col_palette_clusters)
names(param$col_clusters) = cluster_names
```

## Visualisation with UMAP {.tabset}
We use a UMAP to visualise and explore a dataset. The goal is to place similar cells together in 2D space, and learn about the biology underlying the data. Cells are color-coded according to the graph-based clustering, and clusters typcially co-localise on the UMAP. 

Take care not to mis-read a UMAP:  

* Parameters influence the plot (we use defaults here)  
* Cluster sizes relative to each other mean nothing, since the method has a local notion of distance  
* Distances between clusters might not mean anything  
* You may need more than one plot  
  
For a nice read to intuitively understand UMAP, see `r knitcitations::citet("https://pair-code.github.io/understanding-umap/")`. 

### Coloured by cluster
```{r umap_by_cluster}
# Default UMAP
sc = suppressWarnings(Seurat::RunUMAP(sc, dims=1:param$pc_n, verbose=FALSE, umap.method="uwot"))

# 3D UMAP
sc = suppressWarnings(Seurat::RunUMAP(sc, dims=1:param$pc_n, n.components=3, reduction.name="umap3d", reduction.key="UMAP3D_", verbose=FALSE, umap.method="uwot"))

# Note that you can set `label = TRUE` or use the LabelClusters function to help label individual clusters
cluster_cells = table(sc@active.ident)
cluster_labels = paste0(levels(sc@active.ident)," (", cluster_cells[levels(sc@active.ident)],")")
p = Seurat::DimPlot(sc, reduction="umap", label=TRUE) + 
  AddStyle(title="UMAP, cells coloured by cluster identity", legend_position="bottom", legend_title="Clusters") + 
  scale_color_manual(values=param$col_clusters, labels=cluster_labels)
p
```

### Coloured by sample 
```{r umap_by_sample}
# Add a UMAP that is coloured by sample of origin
cell_samples = sc[[]] %>% dplyr::pull(orig.ident) %>% unique() %>% sort()

# Note: This is a hack to colour by sample but label by Cluster
p = Seurat::DimPlot(sc, group.by="orig.ident", pt.size=1, cols=param$col_samples) +
  AddStyle(title="UMAP, cells coloured by sample of origin", legend_position="bottom")
p$data$seurat_clusters = sc[["seurat_clusters"]][rownames(p$data),]
p = LabelClusters(p, id="seurat_clusters")
p
```

## Distribution of cells in clusters

```{r cells_per_cluster}
# Count cells per cluster per sample 
cell_samples = sc[[]] %>% dplyr::pull(orig.ident) %>% unique() %>% sort()
cell_clusters = sc[[]] %>% dplyr::pull(seurat_clusters) %>% unique() %>% sort()
tbl = mapply(function(cl) { 
  sapply(cell_samples, function(s) sc[[]] %>% dplyr::filter(orig.ident==s, seurat_clusters==cl) %>% nrow())
  }, cell_clusters)
colnames(tbl) = paste0("Cl_", cell_clusters)
rownames(tbl) = paste0(cell_samples, "_n")

# Add percentages
tbl_perc = round(t(tbl) / colSums(tbl) * 100, 2) %>% t()
rownames(tbl_perc) = gsub(rownames(tbl_perc), pattern="_n$", replacement="_perc", perl=TRUE)
tbl = rbind(tbl, tbl_perc)

# Add enrichment
if (length(cell_samples) > 1) tbl = rbind(tbl, cells_fisher(sc))

# Sort
tbl = tbl[order(rownames(tbl)),]

# Plot percentages
tbl_bar = tbl[paste0(cell_samples, "_perc"),] %>% 
  tibble::rownames_to_column(var="Sample") %>%
  tidyr::pivot_longer(tidyr::starts_with("Cl"), names_to="Cluster", values_to="Percentage")
tbl_bar$Cluster = tbl_bar$Cluster %>% gsub(pattern="^Cl_", replacement="", perl=TRUE) %>% as.factor()
tbl_bar$Sample = tbl_bar$Sample %>% gsub(pattern="_perc$", replacement="", perl=TRUE) %>% as.factor()
tbl_bar$Percentage = as.numeric(tbl_bar$Percentage)
p = ggplot(tbl_bar, aes(x=Cluster, y=Percentage, fill=Sample)) + 
  geom_bar(stat="identity" ) +
  AddStyle(title="Percentage cells of samples in clusters",
           fill=param$col_samples,
           legend_title="Sample",
           legend_position="bottom")
p
```

The following table shows the number of cells per sample per cluster:   

* n: Number of cells per sample per cluster   
* perc: Percentage of cells per sample per cluster compared to all other cells of that cluster   

In case the dataset contains 2 or more samples, we also calculate whether or not the number of cells of a sample in a cluster is significantly higher than expected:      

* oddsRatio: Odds ratio calculated for cluster c1 and sample s1 as (# cells s1 in c1 / # cells not s1 in c1) / (# cells s1 not in c1 / # cells not s1 not in c1)    
* p: P-value calculated with a Fisher test to test whether "n" is higher than expected  

```{r cells_per_cluster_table}
# Print table
knitr::kable(tbl, align="l", caption="Number of cells per cluster per sample") %>% 
  kableExtra::kable_styling(bootstrap_options = c("striped", "hover")) %>% 
  kableExtra::scroll_box(width="100%")
```

```{r reset_default_assay}
# Reset default assay, so we won't plot integrated data
# Note: We need integrated data for UMAP, clusters
DefaultAssay(sc) = param$norm
```

## Cell Cycle Effect {.tabset}
How much do gene expression profiles in the dataset reflect the cell cycle phases the single cells were in? After initial normalisation, we determined the effects of cell cycle heterogeneity by calculating a score for each cell based on its expression of G2M and S phase markers. Scoring is based on the strategy described in `r knitcitations::citet("10.1126/science.aad0501")`, and human gene symbols are translated to gene symbols of the species of interest using biomaRt. This section of the report visualises the above calculated cell cycle scores. 
```{r cellCycleEffect}
# Get a feeling for how many cells are affected
p1 = ggplot(sc[[]], aes(x=S.Score, y=G2M.Score, colour=Phase)) + 
  geom_point() + 
  scale_x_continuous("G1/S score") + 
  scale_y_continuous("G2/M score") + 
  AddStyle()
p2 = ggplot(sc@meta.data %>% 
              dplyr::group_by(seurat_clusters,Phase) %>% 
              dplyr::summarise(num_reads=length(Phase)), 
            aes(x=seurat_clusters, y=num_reads, fill=Phase)) + 
  geom_bar(stat="identity", position="fill") + 
  scale_x_discrete("Seurat clusters") + 
  scale_y_continuous("Fraction of cells") + 
  AddStyle()
p = p1 + p2 & theme(legend.position="bottom")
p = p + patchwork::plot_annotation(title="Cell cycle phases")
p
```

### UMAP coloured by cell cycle phases
```{r cellCycleEffect_umap_phases}
# UMAP with phases superimposed
# Note: This is a hack to colour by phase but label by Cluster
p = Seurat::DimPlot(sc, group.by="Phase", pt.size=1) + 
  AddStyle(title="UMAP, cells coloured by cell cycle phases", legend_title="Phase")
p$data$seurat_clusters = sc[["seurat_clusters"]][rownames(p$data),]
p = LabelClusters(p, id = "seurat_clusters")
p
```

### UMAP coloured by S phase
```{r cellCycleEffect_umap_s}
p = Seurat::FeaturePlot(sc, features="S.Score", pt.size=1, min.cutoff="q1", max.cutoff="q99", label=TRUE, cols=c("lightgrey", param$col)) + 
  AddStyle(title="UMAP, cells coloured by S phase")
p
```

### UMAP coloured by G2/M phase
```{r cellCycleEffect_umap_g2m}
p = Seurat::FeaturePlot(sc, features="G2M.Score", pt.size=1, min.cutoff="q1", max.cutoff="q99", cols=c("lightgrey", param$col), label=TRUE) + 
  AddStyle(title="UMAP, cells coloured by G2M phase")
p
```

### UMAP coloured by the difference between S and G2/M phase
```{r cellCycleEffect_umap_ccdiff}
p = Seurat::FeaturePlot(sc, features="CC.Difference", pt.size=1, min.cutoff="q1", max.cutoff="q99", cols=c("lightgrey", param$col), label=TRUE) +
  AddStyle(title="UMAP, cells coloured by CC.Difference")
p
```

## Cluster QC  {.tabset}
Do cells in individual clusters have particularly high counts, detected genes or mitochondrial content?

### Number of counts 
```{r clusterQC_nCount_featurePlot}
p1 = Seurat::FeaturePlot(sc, features="nCount_RNA", cols=c("lightgrey", param$col), label=TRUE) + 
  AddStyle(title="Feature plot")

p2 = ggplot(sc[[]], aes(x=seurat_clusters, y=nCount_RNA, fill=seurat_clusters)) + 
  geom_violin(scale="width") + 
  AddStyle(title="Violin plot", fill=param$col_clusters,
           xlab="Cluster", legend_position="none")

p = p1 | p2 
p = p + patchwork::plot_annotation(title="Summed raw counts (nCount_RNA)")
p
```

### Number of features
```{r clusterQC_nFeature_featurePlot}
p1 = Seurat::FeaturePlot(sc, features="nFeature_RNA", cols=c("lightgrey", param$col), label=TRUE) + 
  AddStyle(title="Feature plot")

p2 = ggplot(sc[[]], aes(x=seurat_clusters, y=nFeature_RNA, fill=seurat_clusters)) + 
  geom_violin(scale="width") + 
  AddStyle(title="Violin plot", fill=param$col_clusters,
           xlab="Cluster", legend_position="none")

p = p1 | p2 
p = p + patchwork::plot_annotation(title="Number of features with raw count > 0 (nFeature_RNA)")
p
```

### Percent mitochondrial reads
```{r clusterQC_mt_featurePlot}
p1 = Seurat::FeaturePlot(sc, features="percent_mt", cols=c("lightgrey", param$col), label=TRUE) + 
  AddStyle(title="Feature plot")

p2 = ggplot(sc[[]], aes(x=seurat_clusters, y=percent_mt, fill=seurat_clusters)) + 
  geom_violin(scale="width") + 
  AddStyle(title="Violin plot", fill=param$col_clusters,
           xlab="Cluster", legend_position="none")

p = p1 | p2 
p = p + patchwork::plot_annotation(title="Percent of mitochondrial features (percent_mt)")
p
```

## Known marker genes {.tabset}
Do cells in individual clusters express provided known marker genes? 
```{r knownMarkers_read}
known_markers_list=c()

# Overwrite empty list of known markers 
if (!is.null(param$file_known_markers)) {
  # Read known marker genes and map to rownames
  known_markers = openxlsx::read.xlsx(param$file_known_markers)
  known_markers_list = lapply(colnames(known_markers), function(x) {
    y = ensembl_to_seurat_rowname[known_markers[,x]] %>% 
      na.exclude() %>% unique() %>% sort()
    m = !y %in% rownames(sc)
    if (any(m)){
      Warning(paste0("The following genes of marker list '", x, "' cannot be found in the data: ", first_n_elements_to_string(y[m], n=10)))
    }
    return(y[!m])
  })
  
  # Remove empty lists
  names(known_markers_list) = colnames(known_markers)
  is_empty = purrr::map_int(known_markers_list, .f=length) == 0 
  known_markers_list = known_markers_list[!is_empty]
}  

# Set plot options
if(length(known_markers_list) > 0) { 
  known_markers_n = length(known_markers_list) 
  known_markers_vect = unlist(known_markers_list) %>% unique() %>% sort()
  idx_dotplot = sapply(seq(known_markers_list), function(x) length(known_markers_list[[x]]) <= 50)
  idx_avgplot = sapply(seq(known_markers_list), function(x) length(known_markers_list[[x]]) >= 10)
} else { 
  known_markers_n=0
  idx_dotplot = idx_avgplot = FALSE
  known_markers_vect = c()
}
```

```{r known_markers_fig_heights}
# Dotplots and average feature plots
# The height of 1 row (= 1 plot) is fixed to 5 
fig_height_knownMarkers_dotplot = max(5, 5 * sum(idx_dotplot))
fig_height_knownMarkers_avgplot = max(5, 5 * sum(idx_avgplot))

# Individual feature plots
# Each row contains 2 plots
# We fix the height of each plot to the same height as is used later for DEGs
cluster_all = sort(unique(levels(Idents(sc))))
height_per_row = max(2, 0.3 * length(cluster_all))
nr_rows = ceiling(length(known_markers_vect)/2)
fig_height_knownMarkers_vect = max(5, height_per_row * nr_rows)
```

You provided `r length(known_markers_list)` list(s) of known marker genes. In the following tabs, you find: 

* Dot plots for all gene lists containing at most 50 genes   
* Average feature plots for all gene lists containing at least 10 genes   
* Individual feature plots for all genes if there are no more than 100 genes in total  

### Dot plot(s)
A dot plot visualizes how gene expression changes across different clusters. The size of a dot encodes the percentage of cells in a cluster that express the gene, while the color encodes the average expression across all cells within the cluster. 
```{r knownMarkers_dotplot, fig.height=fig_height_knownMarkers_dotplot}
if ((known_markers_n > 0) & any(idx_dotplot)) {
  known_markers_dotplot = known_markers_list[idx_dotplot]
  p_list = list()
  for (i in seq(known_markers_dotplot)) {
    g = known_markers_dotplot[[i]]
    g = g[length(g):1]
    p_list[[i]] = Seurat::DotPlot(sc, features=g, cols=c("lightgrey", param$col)) + 
      AddStyle(title=paste("Known marker genes:", names(known_markers_dotplot)[i]), 
               ylab="Cluster") + 
      theme(axis.text.x = element_text(angle=90, hjust=1, vjust=.5))
  }
  p = patchwork::wrap_plots(p_list, ncol=1)
  print(p)
} else if ((known_markers_n > 0) & !any(idx_dotplot)) {
  message("This tab is used for dot plots for up to 50 genes. All provided lists are longer than this, and hence dot plots are skipped.")
} else {
  message("No known marker genes were provided and hence dot plots are skipped.")
}
```

### Average feature plot(s)
An average feature plot visualizes the average gene expression of each gene list on a single-cell level, subtracted by the aggregated expression of control feature sets. The color of the plot encodes the calculated scores, whereat positive scores suggest that genes are expressed more highly than expected. 
```{r knownMarkers_umap, fig.height=fig_height_knownMarkers_avgplot}
if ((known_markers_n > 0) & any(idx_avgplot)) {
  known_markers_avgplot = known_markers_list[idx_avgplot]
  sc = Seurat::AddModuleScore(sc, features=known_markers_avgplot, assay="SCT", ctrl=10, name="known_markers")
  idx_replace_names = grep("^known_markers[0-9]+$", colnames(sc@meta.data), perl=TRUE)
  colnames(sc@meta.data)[idx_replace_names] = names(known_markers_avgplot)
  p_list = Seurat::FeaturePlot(sc, features=names(known_markers_avgplot), cols=c("lightgrey", param$col), combine=FALSE, label=TRUE)
  for (i in seq(known_markers_avgplot)) {
    p_list[[i]] = p_list[[i]] + AddStyle(title=paste("Known marker genes:", names(known_markers_avgplot)[i]))
  }
  p = patchwork::wrap_plots(p_list, ncol=1)
  print(p)
} else if ((known_markers_n > 0) & !any(idx_avgplot)) {
  message("This tab is used to plot an average for 10 or more genes. All provided lists are shorter than this, and hence average feature plots are skipped.")
} else {
  message("No known marker genes were provided and hence average feature plots are skipped.")
}
```

### Individual feature plots
An individual feature plot colours single cells on the UMAP according to their normalised gene expression. 
```{r knownMarkers_all, fig.height=fig_height_knownMarkers_vect}
if ((known_markers_n > 0) & length(known_markers_vect) <= 100) {
  p_list = Seurat::FeaturePlot(sc, features=known_markers_vect, cols=c("lightgrey", param$col), combine=FALSE, label=TRUE)
  for (i in seq(p_list)) p_list[[i]] = p_list[[i]] + AddStyle()
  p = patchwork::wrap_plots(p_list, ncol=2)
  print(p)
} else if (length(known_markers_vect) > 100) { 
  message("This tab is used to plot up to 100 known marker genes. Your provided list is longer than this, and hence individual feature plots are skipped.")
} else {
  message("No known marker genes were provided and hence individual feature plots are skipped.")
}
```

## Differentially expressed genes, comparing one cluster against the rest (marker genes)
We next identify genes that are differentially expressed in one cluster compared to all other clusters, based on raw "RNA" data and the method "MAST". Resulting _p_-values are adjusted using the Bonferroni method. The names of differentially expressed genes per cluster, alongside statistical measures and additional gene annotation are written to file.
```{r degs, warning=FALSE}
# We load and unload the MAST R package in this chunk, as it overwrites Seurat functions
suppressPackageStartupMessages(library(MAST))
degs_found = TRUE

# Find DEGs for every cluster compared to all remaining cells, report positive (=markers) and negative ones
# min.pct = requires feature to be detected at this minimum percentage in either of the two groups of cells 
# logfc.threshold = requires a feature to be differentially expressed on average by some amount between the two groups
# only.pos = find only positive markers 

# Review recommends using "MAST"; Mathias uses "LR"
# ALWAYS USE: assay="RNA" or assay="SCT"
# DONT USE: assay=integrated datasets; this data is normalised and contains only 2k genes
# Note: By default, the function uses slot="data". Mast requires log data, so this is the correct way to do it.
#   https://www.bioconductor.org/packages/release/bioc/vignettes/MAST/inst/doc/MAST-interoperability.html
degs = suppressMessages(Seurat::FindAllMarkers(sc, assay="RNA", test.use="MAST",
                                               only.pos=FALSE, min.pct=0.25, logfc.threshold=0.25,
                                               latent.vars=param$latent_vars, verbose=FALSE, silent=TRUE))

# If no degs are found, initialize the degs table so that further downstream (export) chunks run
if (ncol(degs) == 0){
  degs$avg_log2FC = degs$p_val = degs$p_val_adj = degs$pct.1 = degs$pct.2 = degs$cluster = as.numeric()
  degs$gene = as.character()
}

# Sort markers
degs = degs %>% DegsSort()
  
# Filter markers 
degs_filt = DegsFilter(degs, cut_log2FC=param$log2FC, cut_padj=param$padj)

# Write and plot only if there are any degs found
if ((nrow(degs) > 0) & (nrow(degs_filt$all) > 0)) {
  
  # Add average data to degs table and write to file
  degs_out = cbind(degs_filt$all, DegsAvgData(sc, genes=degs_filt$all$gene))
  DegsWriteToFile(degs_out, annot_ensembl=annot_ensembl, file=paste0(param$path_out, "/degs_cluster_vs_rest.xlsx"))

  # Plot number of differentially expressed genes
  p = DegsPlotNumbers(degs_up=degs_filt$up, degs_down=degs_filt$down, 
                      title=paste0("Number of DEGs, comparing each cluster to the rest\n(FC=", 2^param$log2FC, ", adj. p-value=", param$padj, ")")) 
  p
  
} else { 

  # Do not run the following degs-related chunks
  degs_found = FALSE
}

# Unload the MAST R package
detach("package:MAST", unload=TRUE)
```

```{r degs_found, eval=!degs_found}
if (!degs_found) warning("No differentially expressed genes found. The following related code is not executed, no degs-related plots and tables are generated.")
```

### Table of top marker genes 
We use the term "marker genes" to specifically describe genes that are up-regulated in cells of one cluster compared to the rest. 
```{r degs_table, eval=degs_found}
if (degs_found) {
  degs_top = DegsUpDisplayTop(degs_filt$up, n=5)

  # Show table
  knitr::kable(degs_top, align="l", caption="Up to top 5 marker genes per cell cluster") %>% 
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover")) %>% 
    kableExtra::scroll_box(width="100%", height="700px") 
}
```

### Visualisation of top marker genes {.tabset}
The following plots are exemplary to how we can visualize differentially expressed genes using the Seurat R-package. The selected genes are the top marker genes for each cluster, respectively. 
```{r degs_plot, eval=degs_found}
if (degs_found) {
  # Get top 1 gene per cluster and plot
  if (nrow(degs_filt$all) > 0) {
    genes_example_df = degs_filt$up %>% 
      dplyr::group_by(cluster) %>% 
      dplyr::top_n(n=1, wt=avg_log2FC) %>% 
      dplyr::select(cluster, gene) %>% 
      as.data.frame()
  } else { 
    genes_example_df = data.frame(cluster=numeric(), gene=character())
  }
  genes_example = genes_example_df$gene 
  genes_example_titles = paste0(genes_example_df$cluster, ": ", genes_example_df$gene)
}
```

```{r degs_fig_heights}
# Note: We need to run this chunk as it specifies a variable that is used in chunk definitions below
if (degs_found) {
  # Each row contains 2 plots
  nr_rows = ceiling(length(genes_example)/2)

  # The height of each plot might depend on the number of clusters 
  height_per_row = max(2, 0.3 * length(cluster_all))

  # Total height of plots 
  fig_height_degs = max(5, height_per_row * nr_rows)
} else {
  fig_height_degs = 7
}
```

#### Feature plots
```{r degs_plot_umap, eval=degs_found, fig.height=fig_height_degs}
if (degs_found) {
  # Shows gene expression on the UMAP
  p_list = Seurat::FeaturePlot(sc, features=genes_example, cols=c("lightgrey", param$col), combine=FALSE, label=TRUE)
  for (i in seq(p_list)) p_list[[i]] = p_list[[i]] + AddStyle(title=genes_example_titles[i])
  p = patchwork::wrap_plots(p_list, ncol=2) + 
    patchwork::plot_annotation(title="UMAP, cells coloured by normalised gene expression data, top 1 marker gene per cluster")
  p
}
```

#### Violin plots (raw)
```{r degs_plot_violin_raw, eval=degs_found, fig.height=fig_height_degs}
if (degs_found) {
  # Violin plot of raw gene expression counts
  p_list = Seurat::VlnPlot(sc, features=genes_example, assay="RNA", slot="counts", combine=FALSE, pt.size=0.2)
  for (i in seq(p_list)) p_list[[i]] = p_list[[i]] + AddStyle(title=genes_example_titles[i], 
                                                              legend_title="Cluster", 
                                                              fill=param$col_clusters, 
                                                              xlab="Cluster")
  p = patchwork::wrap_plots(p_list, ncol=2) + 
    patchwork::plot_annotation(title="Violin plot of raw gene expression counts, top 1 marker gene per cluster") + 
    patchwork::plot_layout(guides = "collect") & theme(legend.position="bottom")
  suppressMessages(p)
}
```

#### Violin plots (normalised)
```{r degs_plot_violin_norm, eval=degs_found, fig.height=fig_height_degs}
if (degs_found) {
  # Violin plot of normalised gene expression data
  p_list = Seurat::VlnPlot(sc, features=genes_example, combine=FALSE, pt.size=0.2)
  for (i in seq(p_list)) p_list[[i]] = p_list[[i]] + AddStyle(title=genes_example_titles[i], 
                                                              legend_title="Cluster", 
                                                              fill=param$col_clusters, 
                                                              xlab="Cluster") 
  p = patchwork::wrap_plots(p_list, ncol=2) + 
    patchwork::plot_annotation(title="Violin plot of normalised gene expression data, top 1 marker gene per cluster") +
    patchwork::plot_layout(guides = "collect") &
    theme(legend.position="bottom")
  suppressMessages(p)
}
```

#### Ridge plots (raw)
```{r degs_plot_ridge_raw, eval=degs_found, fig.height=fig_height_degs, message=FALSE}
if (degs_found) {
  # Ridge plot of raw gene expression counts
  p_list = Seurat::RidgePlot(sc, features=genes_example, assay="RNA", slot="counts", combine=FALSE)
  for (i in seq(p_list)) {
    p_list[[i]] = p_list[[i]] + AddStyle(title=genes_example_titles[i], 
                                         legend_title="Cluster", 
                                         fill=param$col_clusters, 
                                         ylab="Cluster")
  }
  p = patchwork::wrap_plots(p_list, ncol=2) + 
    patchwork::plot_annotation(title="Ridge plot of raw gene expression counts, top 1 marker gene per cluster") + 
    patchwork::plot_layout(guides = "collect") &
    theme(legend.position="bottom")
  suppressMessages(p)
}
```

#### Ridge plots (normalised)
```{r degs_plot_ridge_norm, eval=degs_found, fig.height=fig_height_degs, message=FALSE}
if (degs_found) {
  # Ridge plot of normalised gene expression data
  p_list = Seurat::RidgePlot(sc, features=genes_example, slot="data", combine=FALSE)
  for (i in seq(p_list)) {
    p_list[[i]] = p_list[[i]] + AddStyle(title=genes_example_titles[i], 
                                         legend_title="Cluster", 
                                         fill=param$col_clusters, 
                                         ylab="Cluster")
  }
  p = patchwork::wrap_plots(p_list, ncol=2) + 
    patchwork::plot_annotation(title="Ridge plot of normalised and log-transformed gene expression data, top 1 marker gene per cluster") + 
    patchwork::plot_layout(guides = "collect") &
    theme(legend.position="bottom")
  suppressMessages(p)
}
```

#### Dot plot
```{r degs_plot_dot, eval=degs_found, fig.height=fig_height_degs*2}
if (degs_found) {
  # Visualises how feature expression changes across different clusters
  p_list = lapply(cluster_all, function(cl) {
    genes = degs_top %>% dplyr::filter(cluster==cl) %>% dplyr::pull(gene)
    if (length(genes) > 0) { 
      genes = genes[length(genes):1]
      p = Seurat::DotPlot(sc, features=genes, cols=c("lightgrey", param$col)) + 
        AddStyle(title=paste0("Top markers (up-regulated genes) for cluster ", cl), ylab="Cluster", legend_position="bottom") + 
        theme(axis.text.x = element_text(angle=90, hjust=1, vjust=.5)) + 
        guides(size=guide_legend(order=1))
      return(p)
    } else { 
      message("No up-regulated genes for cluster ", cl, ".")
      return(NULL)
    }
  })
}
```

### Heatmaps of all differentially expressed genes {.tabset}
#### Up- and down-regulated genes
```{r degs_heatmap_all, eval=degs_found, fig.height=20}
# Let us re-think if we want to limit the number of cells in this plot, since this takes a while. 

if (degs_found) {
  # Heatmap of all differentially expressed genes
  p = Seurat::DoHeatmap(sc, features=degs_filt$all$gene, group.colors=param$col_clusters, label=FALSE) + 
    NoLegend() + 
    theme(axis.text.y=element_blank()) +
    ggtitle("Heatmap of scaled gene expression data, all genes differentially expressed between a cluster and the rest")
  p
}
```

#### Up-regulated genes (marker genes)
```{r degs_heatmap_all_up, eval=degs_found, fig.height=20}
if (degs_found) {
  # Heatmap of all up-regulated genes
  p = Seurat::DoHeatmap(sc, features=degs_filt$up$gene, group.colors=param$col_clusters, label=FALSE) + 
    NoLegend() + 
    theme(axis.text.y=element_blank()) +
    ggtitle("Heatmap of scaled gene expression data, genes up-regulated in a cluster compared to the rest")
  p
}
```

#### Down-regulated genes
```{r degs_heatmap_all_down, eval=degs_found, fig.height=20}
if (degs_found) {
  # Heatmap of all differentially expressed genes
  p = Seurat::DoHeatmap(sc, features=degs_filt$down$gene, group.colors=param$col_clusters, label=FALSE) + 
    NoLegend() + 
    theme(axis.text.y=element_blank()) +
    ggtitle("Heatmap of scaled gene expression data, , genes down-regulated in a cluster compared to the rest")
  p
}
```

### Functional enrichment analysis
To gain first insights into potential functions of cells in a cluster, we test for over-representation of functional terms amongst up- and down-regulated genes of each cluster. Over-represented terms are written to file.  

We first translate gene symbols of up- and down-regulated genes per cluster into Entrez gene symbols, and then use the "enrichR" R-package to access the "Enrichr" website `r knitcitations::citep("https://amp.pharm.mssm.edu/Enrichr/")`. You can choose to test functional enrichment from a wide range of databases:
```{r enrichr_databases}
dbs_all = enrichR::listEnrichrDbs()
knitr::kable(dbs_all, align="l", caption="Enrichr databases") %>% 
  kableExtra::kable_styling(bootstrap_options=c("striped", "hover")) %>% 
  kableExtra::scroll_box(width="100%", height="300px")
```

```{r functional_enrichment, results="hide"}
# Note: We need to run this chunk to initialize the variable "enriched", which is used during the Cerebro export
if (degs_found) {
  # DEGs up and down per cluster
  genesets_up = lapply(cluster_all, function(x) {
    tmp = degs_filt$up %>% 
      dplyr::filter(cluster==x) %>% 
      dplyr::pull(gene)
    # Pick the first matching Entrez symbol
    tmp = sapply(tmp, function(x) seurat_rowname_to_entrez[[x]][1]) %>% 
      na.exclude() %>% unique()
    return(tmp)
  })
  genesets_down = lapply(cluster_all, function(x) {
    tmp = degs_filt$down %>% 
      dplyr::filter(cluster==x) %>% 
      dplyr::pull(gene)
    # Pick the first matching Entrez symbol
    tmp = sapply(tmp, function(x) seurat_rowname_to_entrez[[x]][1]) %>% 
      na.exclude() %>% unique()
    return(tmp)
  })
  names(genesets_up) = paste0("DEG_up_cluster_", cluster_all)
  names(genesets_down) = paste0("DEG_down_cluster_", cluster_all)
  genesets = c(genesets_up, genesets_down)
  
  # Loop through gene lists
  enriched = list()
  for (i in seq(genesets)) {
    if (length(genesets[[i]]) >= 3) {
      enriched[[i]] = enrichR::enrichr(genesets[[i]], databases=param$enrichr_dbs)
      enriched[[i]] = purrr::map(enriched[[i]], function(df) {
        df %>% dplyr::filter(Adjusted.P.value < param$p_enrichr)
      })
    
      # No enrichments found -> remove entry from the results 
      idx_rm = sapply(seq(enriched[[i]]), function(j) nrow(enriched[[i]][[j]]) == 0)
      if (sum(idx_rm) == length(param$enrichr_dbs)) {
        message("Geneset ", names(genesets)[i], " does not result in any functional enrichments.")
        enriched[[i]] = NA
      } else if (sum(idx_rm) > 0) {
        enriched[[i]][idx_rm] = NULL
      }
    } else { 
      message("Geneset ", names(genesets)[i], " has less than 3 genes, we skip enrichr.")
      enriched[[i]] = NA
    }
  }
  names(enriched) = names(genesets)

  # Remove NA entries for lists that were too short to be tested
  is_na = is.na(enriched)
  if (sum(is_na) > 0) enriched = enriched[!is_na]

  # Write enrichment results to file
  enriched_top = matrix(NA, nrow=0, ncol=6)
  colnames(enriched_top) = c("GeneSet", "Database", "Term", "Overlap", "Adjusted_pval", "Genes")
  for (i in seq(enriched)) { 
    if (!is.null(enriched[[i]])) { 
      openxlsx::write.xlsx(enriched[[i]], file=paste0(param$path_out, "/Functions_", names(enriched)[i], ".xlsx"))
    }
  }
} else { 
  enriched=list()
}
```

The following table contains the top enriched term per geneset and database. 
```{r functional_enrichment_results, eval=degs_found}
if (degs_found) {
  for (i in seq(enriched)) { 
    if (!is.null(enriched[[i]])) { 
  
      # Remember top term per geneset
      for (j in seq(enriched[[i]])) {
          enriched_top = rbind(enriched_top, 
                               c(names(enriched)[i], 
                               names(enriched[[i]])[j], 
                               enriched[[i]][[j]][1, c("Term", "Overlap", "Adjusted.P.value", "Genes")]))
      }
    }
  }

  # Print table of top terms per gene set
  knitr::kable(enriched_top, align="l", caption="Top enriched term per geneset") %>% 
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover")) %>% 
    kableExtra::scroll_box(width="100%", height="700px")
}
```

# Further analysis with other tools

## Export to Loupe Cell Browser
We export the UMAP 2D visualisation, metadata such as the cell clusters, and lists of differentially expressed genes, so you can open and work with these in the Loupe Cell Browser.  
```{r loupe_integration}
# Export UMAP coordinates
loupe_umap = as.data.frame(sc@reductions$umap@cell.embeddings)
loupe_umap = cbind(Barcode=rownames(loupe_umap), loupe_umap)
colnames(loupe_umap) = c("Barcode", "UMAP-1", "UMAP-2")
write.table(loupe_umap, file=paste0(param$path_out, "/Seurat2Loupe_umap.csv"), col.names=TRUE, row.names=FALSE, quote=FALSE, sep=",")

# Export categorical metadata
loupe_meta = as.data.frame(sc@meta.data)
idx_keep = sapply(1:ncol(loupe_meta), function(x) !is.numeric(loupe_meta[,x]))
loupe_meta = cbind(Barcode=rownames(loupe_meta), loupe_meta[, idx_keep])
write.table(x=loupe_meta, file=paste0(param$path_out, "/Seurat2Loupe_metadata.csv"), col.names=TRUE, row.names=FALSE, quote=FALSE, sep=",")

# Export gene sets
loupe_genesets = data.frame(List=vapply(degs_filt$up[,"cluster"], paste0, "DEG_up_cluster_"), 
                            Name=degs_filt$up[,"gene"], 
                            Ensembl=seurat_rowname_to_ensembl[degs_filt$up[,"gene"]])
loupe_genesets = rbind(loupe_genesets, 
                       data.frame(List=vapply(degs_filt$down[,"cluster"], paste0, "DEG_down_cluster_"), 
                                  Name=degs_filt$down[,"gene"], 
                                  Ensembl=seurat_rowname_to_ensembl[degs_filt$down[,"gene"]]))

genesets_to_export = list(genes_cc_s_phase=genes_s[,2], genes_cc_g2m_phase=genes_g2m[,2])
for (i in names(genesets_to_export)) {
  tmp_genes = genesets_to_export[[i]]
  tmp_genes = tmp_genes[tmp_genes %in% names(symbol_to_ensembl)]
  loupe_genesets = rbind(loupe_genesets,
                         data.frame(List=i,
                                    Name=tmp_genes,
                                    Ensembl=seurat_rowname_to_ensembl[tmp_genes]))
}

write.table(loupe_genesets, file=paste0(param$path_out, "/Seurat2Loupe_genesets.csv"), col.names=TRUE, row.names=FALSE, quote=FALSE, sep=",")
```

## Export to the Cerebro Browser
We export the assay data, clustering, visualisation, marker genes and enriched pathways in a format that can be read by the Cerebro Browser `r knitcitations::citep("https://github.com/romanhaa/cerebroApp/")`
```{r cerebro_integration, message=FALSE, warning=FALSE}
# top expressed genes
sc = cerebroApp::getMostExpressedGenes(sc, column_cluster="seurat_clusters", column_sample="orig.ident", assay=Seurat::DefaultAssay(sc))

gene_lists_for_cerebro = list()
if (degs_found) {
  gene_lists_for_cerebro = split(degs_filt$all$gene, degs_filt$all$cluster)
  names(gene_lists_for_cerebro) = paste("Marker cluster", names(gene_lists_for_cerebro))
}
gene_lists_for_cerebro[["G2M_phase_genes"]] = genes_g2m[, 2]
gene_lists_for_cerebro[["S_phase_genes"]] = genes_s[, 2]
gene_lists_for_cerebro[["mitochondrial_genes"]] = grep(param$mt, rownames(sc), v=TRUE)
cerebro_species = gsub("_gene_ensembl", "", param$mart_dataset)
cerebro_species = ifelse(grepl("sapiens", cerebro_species), "Hg", ifelse(grepl("musculus", cerebro_species), "Mm", cerebro_species))

res = ExportToCerebro(sc=sc, path=paste0(param$path_out,"/cerebro.crb"), param=param, project=param$project_id, species=cerebro_species, assay=DefaultAssay(sc), column_sample="orig.ident", column_cluster="seurat_clusters", column_ccphase="Phase", gene_lists=gene_lists_for_cerebro, marker_genes=degs_filt$all, enriched_pathways=enriched)
```

# Output files
All files generated with this report are written into the provided output folder `r param$path_out`: 

* Annotation files  
  + `r basename(param$file_annot)`: Table that contains several identifiers and annotation (columns) per gene (rows) (optional)   
* Differentially expressed genes  
  + degs_cluster_vs_rest.xlsx: Excel file with one tab per cell cluster  
* Functional enrichment of differentially expressed genes per cell cluster  
  + Functions_DEG_down_cluster_1.xlsx, Functions_DEG_up_cluster_1.xlsx, ...: Excel files with one tab per database
* Loupe Cell Browser files  
  + Seurat2Loupe_umap.csv: Seurat UMAP 2D visualisation   
    Import to Loupe through "Import Projection"   
  + Seurat2Loupe_metadata.csv: Seurat categorial meta data including clusters and cell cycle phases   
    Import to Loupe through "Import Categories"   
  + Seurat2Loupe_genesets.csv: Seurat differentially expressed genes   
    Import to Loupe through "Import Lists"   
* Cerebro files:
  + cerebro.crb: Can be loaded into the Cerebro Browser  
  
```{r save}
# Add colors to the sc object for compatibility with downstream tools
# List names should correspond to meta-data columns
# This could be done for other meta-data as well 
sc@misc$colors = list("orig.ident" = param$col_samples,
                      "seurat_clusters" = param$col_clusters)

save.image(file=paste0(param$path_out, "/scrnaseq.RData"))
```

# Parameter table
The following parameters were used to run the workflow.  
```{r parameters_table}
out = scrnaseq_params_info(params=param)

knitr::kable(out, align="l") %>% 
  kableExtra::kable_styling(bootstrap_options = c("striped", "hover"), full_width=FALSE, position="left")
```

# Software versions
This report was generated using the [scrnaseq](https://github.com/ktrns/scrnaseq) GitHub repository. Software versions were collected at run time. 
```{r versions, message=FALSE}
out = scrnaseq_session_info(param$path_to_git)

knitr::kable(out, align="l") %>% 
  kableExtra::kable_styling(bootstrap_options = c("striped", "hover"))
```

# References
```{r bib, message=FALSE}
knitcitations::write.bibtex(file="references.bib")
```
