---
# Module-specific parameters (that are not already in the profile yaml)
params:
  # Name of the module used in configurations
  module: "preprocessing_rna"
    
  # Relative path to the module directory (which contains the qmd file)
  module_dir: "modules/2_preprocessing/rna"
  
  # Path to previous module. If null, will be read from the 'chapters' entry in the profile yaml
  prev_module_dir: null
  
  # Default assay.
  default_assay: "RNA"
  
  # For large datasets: Do not keep counts in memory but store on disk in matrix directories. Computations will access only the relevant parts of the data. Once done, matrix directories will be saved together with the Seurat object in the module directory.
  on_disk_counts: true
  
  # For large datasets: Copy matrix directories to a temporary directory for computations. This will improve performance if the temporary directory  has a better performance than normal disks (e.g. SSD). Once done, matrix directories will be copied back to the module directory. The temporary directory will be deleted once the R session exists.
  on_disk_use_tmp: false
  
  # Which barcode QC should be shown. Can be any barcode metadata column. 
  # If the assay is not part of the name, will use the default assay (nFeature => nFeature_RNA).
  barcode_qc:
  - "nCount"
  - "nFeature"
  - "pCountsTop50"
  - "pMito"
  - "pGlobin"
  
  # Which pairs of barcode QC should be should be plotted in scatter plots. 
  # Seperate QC by space character. Can only be numeric barcode metadata columns. 
  # If the assay is not part of the name, will use the default assay (nFeature => nFeature_RNA).
  barcode_qc_cor:
  - "nFeature nCount"
  - "nFeature pMito"

  # Filter for barcodes
  barcode_filter: !expr list(
    nCount_RNA = c(1000, NA),
    nFeature_RNA = c(400, 4000))

  # Filter for features
  feature_filter: !expr list(
    min_counts = 1,
    min_cells = 3)
    
  # List of samples to drop after initial QC. Set to 'null' for an empty list.
  # Example:
  #  - sampleA
  #  - sampleB
  samples_to_drop: null

  # Drop samples with too few cells
  samples_min_cells: 10
  
# Module execution
execute:
  # Should this module be frozen and never re-rendered?
  # - auto: if the code has not changed (default)
  # - true/false: freeze/re-render
  # Does not apply in interactive mode or when explicitly rendering this document via in rstudio
  freeze: auto
---

# Preprocessing (RNA)

## Overview

In this chapter, we read in counts data as "features x barcodes" matrices. If provided, we read in additional metadata for features and barcodes. For spatial data, we additionally read in the image data. All data is imported into an Seurat object. Basic summary stats are calculated and shown. Finally, the Seurat object is saved for further processing in the next chapters.


```{r}
#| label: setup
#| message: false
#| warning: false

# If running code interactively in rstudio, set profile here
# When rendering with quarto, profile is already set and should not be overwritten
if (nchar(Sys.getenv("QUARTO_PROFILE")) == 0) {Sys.setenv("QUARTO_PROFILE" = "default")}

# Source general configurations (always)
source("R/general_configuration.R")

# Source required R functions
source("R/functions_util.R")
source("R/functions_io.R")
source("R/functions_plotting.R")
source("R/functions_analysis.R")

# Load libraries
library(knitr)
library(magrittr)
library(gt)
library(Seurat)
library(ggplot2)
library(future)

# Get module name and directory (needed to access files within the module directory)
module_name = params$module_name
module_dir = params$module_dir

# Parallelisation plan for all functions that support future
plan(multisession, workers=4, gc=TRUE)
```

```{r}
#| label: preprocess_rna_preparation

###############
# Directories #
###############

# Module directory 'results' contains all output that should be provided together with the final report of the project
dir.create(file.path(module_dir, "results"), showWarnings=FALSE)
files = list.files(path=file.path(module_dir, "results"), full.names=TRUE)
if (length(files) > 0) unlink(files, recursive=TRUE)

# Module directory 'sc' contains the final Seurat object
dir.create(file.path(module_dir, "sc"), showWarnings=FALSE)
files = list.files(path=file.path(module_dir, "sc"), full.names=TRUE)
if (length(files) > 0) unlink(files, recursive=TRUE)

#################
# Seurat object #
#################

# Read in seurat object
if (!is.null(param("prev_module_dir"))) {
  prev_module_dir = param("prev_module_dir")
} else {
  prev_module_dir = PreviousModuleDir(module_dir)
}
prev_sc_obj = file.path(prev_module_dir, "sc", "sc.rds")
if(!file.exists(prev_sc_obj)) {
  stop(FormatMessage("Could not find a sc.rds file in {{prev_module_dir}}. Was the respective module already run?"))
}
sc = SeuratObject::LoadSeuratRds(prev_sc_obj)

# Move on-disk layers to faster temp location if requested
on_disk_counts = param("on_disk_counts")
on_disk_use_tmp = param("on_disk_use_tmp")

if (on_disk_counts & on_disk_use_tmp) {
  on_disk_path = tempdir()
  with_progress({
    sc = UpdateMatrixDirs(sc, dir=on_disk_path)
  })
}

# Set default assay
default_assay = param("default_assay")
Seurat::DefaultAssay(sc) = default_assay

###############################################
# Needed for some of the tasks in this module #
###############################################

# Apply a basic normalization and find variable features 
sc = Seurat::NormalizeData(sc, normalization.method="LogNormalize", scale.factor=10000, verbose=FALSE)
sc = Seurat::FindVariableFeatures(sc, verbose=FALSE, selection.method="vst")

# If more than 5000 barcodes, sketch a subset of 5000 barcodes
# Note: assay is saved in memory (not on-disk)
if (length(Seurat::Cells(sc)) > 5000) {
  sc = Seurat::SketchData(sc, 
                       ncells=5000,
                       sketched.assay=paste0(default_assay, "Sketch"))
  SeuratObject::DefaultAssay(sc) = paste0(default_assay, "Sketch")
}

# Run a "quick" single-cell analysis
sc = Seurat::NormalizeData(sc, normalization.method="LogNormalize", scale.factor=10000, verbose=FALSE)
sc = Seurat::FindVariableFeatures(sc, verbose=FALSE, selection.method="vst")
sc = Seurat::ScaleData(sc, verbose=FALSE)
sc = Seurat::RunPCA(sc, verbose=FALSE, seed.use=getOption("random_seed"))
default_reduction = "pca"

num_datasets = length(SeuratObject::Layers(sc, search="^counts"))
if (num_datasets > 1) {
  sc = Seurat::IntegrateLayers(sc, 
                               method=Seurat::CCAIntegration, 
                               orig.reduction="pca",
                               new.reduction="integrated.cca", 
                               verbose=FALSE)
  default_reduction = "integrated.cca"
}

sc = Seurat::FindNeighbors(sc, reduction=default_reduction, dims=1:10)
sc = Seurat::FindClusters(sc, resolution=0.5, verbose=FALSE)
sc = Seurat::RunUMAP(sc, dims=1:10, reduction=default_reduction)


# Done
Seurat::DefaultAssay(sc) = default_assay
Seurat::Idents(sc) = "orig.ident"
```

```{r}
#| label: preprocess_rna_qc_barcodes

############
# Barcodes #
############

barcode_metadata = sc[[]]
feature_metadata = sc[[default_assay]][[]]

# Calculate percentage of counts in mitochondrial genes
mt_features = grep(pattern="^MT-", x=rownames(feature_metadata), value=TRUE, ignore.case=TRUE)
sc[[]][paste("pMito", default_assay, sep="_")] = Seurat::PercentageFeatureSet(sc, features=mt_features)

# Calculate percentage of counts in ribosomal genes
ribo_features = grep(pattern="^RP[SL]", x=rownames(feature_metadata), value=TRUE, ignore.case=TRUE)
sc[[paste("pRibosomal", default_assay, sep="_")]] = Seurat::PercentageFeatureSet(sc, features=ribo_features)

# Calculate percentage of counts in globin genes
globin_features = grep("^HB[ABDGEMQZ]", x=rownames(feature_metadata), value=TRUE, ignore.case=TRUE)
sc[[paste("pGlobin", default_assay, sep="_")]] = Seurat::PercentageFeatureSet(sc, features=globin_features)

# Calculate percentage of counts in globin genes
ercc_features = grep("^ERCC-", x=rownames(feature_metadata), value=TRUE, ignore.case=TRUE)
sc[[paste("pERCC", default_assay, sep="_")]] = Seurat::PercentageFeatureSet(sc, features=ercc_features)

# Calculate number of counts in XIST
xist_feature = grep("^XIST", x=rownames(feature_metadata), value=TRUE, ignore.case=TRUE)
sc[[paste("pXIST", default_assay, sep="_")]] = Seurat::PercentageFeatureSet(sc, assay=default_assay, features=xist_feature)

# Calculate percentage of counts in chrY genes
sc[[paste("pChrY", default_assay, sep="_")]] = 0
if ("ensembl_chr" %in% colnames(feature_metadata)) {
  chrY_features = which(feature_metadata$ensembl_chr %in% c("chrY", "Y"))
  sc[[paste("pChrY", default_assay, sep="_")]] = Seurat::PercentageFeatureSet(sc, features=chrY_features)
}
```

```{r}
#| label: preprocess_rna_qc_features

############
# Features #
############

orig_idents = levels(sc$orig.ident)
feature_filter = PrepareFeatureFilter(param("feature_filter"), orig_idents)

# Calculate number of barcodes above threshold for each layer (dataset)
for (l in SeuratObject::Layers(sc, "^counts")) {
  n = gsub(x=l, pattern="counts\\.", replacement="")

  # Get data for layer (sample) and count
  counts = sc[[default_assay]][l]
  num_bcs_expr = rowSums(counts >= feature_filter[[n]]$min_counts)
  
  # Add to metadata
  sc[[default_assay]][[paste("nBcsThreshold", n, sep="_")]] = num_bcs_expr
}

```

## Basic quality control 

### Overall

```{r}
#| label: preprocess_rna_qc_plots
#| results: asis

orig_idents = levels(sc$orig.ident)
barcode_metadata = sc[[]]
barcode_filter = PrepareBarcodeFilter(param("barcode_filter"), orig_idents)

# Find barcode QC columns
barcode_qc = param("barcode_qc")
idx = which(!barcode_qc %in% colnames(barcode_metadata))
if (length(idx) > 0) {
  barcode_qc_assay = barcode_qc
  barcode_qc_assay[idx] = paste(barcode_qc_assay[idx], default_assay, sep="_")
  f = barcode_qc_assay %in% colnames(barcode_metadata)
  assertthat::assert_that(all(f),
                          msg=FormatMessage("Cannot find QC {barcode_qc_assay[!f]*} in barcode metadata."))
  barcode_qc = barcode_qc_assay
}

# Make plots
plist = PlotBarcodeQC(sc, qc=barcode_qc, filter=barcode_filter)

# Prepare captions
captions = GeneratePlotCaptions(names(plist), remove=paste0("_", default_assay))

# Set up layout and generate chunks
chunk_template = "
\`\`\`{r}
#| label: fig-preprocessing_rna_qc_{{type}}
#| fig-asp: 0.5
#| fig-cap: '{{caption}}'
#| echo: false
#| warning: false

print(plist[[{{i}}]])
\`\`\`
"

if (length(orig_idents) <= 10) {
  cat("::: {layout-ncol=2}", sep="\n")
} else {
  cat("::: {layout-ncol=1}", sep="\n")
}

for (i in seq(plist)) {
  chunk_filled =  knitr::knit_expand(text=chunk_template, type=barcode_qc[i], i=i, caption=captions[i])
  if(interactive()) {
    EvalKnitrChunk(chunk_filled)
  } else {
    chunk_filled = knitr::knit_child(text=chunk_filled, envir=environment(), quiet=TRUE)
    cat(chunk_filled, sep='\n')
  }
}

cat(":::", sep="\n")
```


```{r}
#| label: preprocess_rna_qc_cor_plots
#| results: asis

orig_idents = levels(sc$orig.ident)
barcode_metadata = sc[[]]
barcode_filter = PrepareBarcodeFilter(param("barcode_filter"), orig_idents)

# Find barcode QC columns
barcode_qc_cor = strsplit(param("barcode_qc_cor"), "\\s+")
barcode_qc_cor = purrr::map(barcode_qc_cor, function(barcode_qc) {
  idx = which(!barcode_qc %in% colnames(barcode_metadata))
  if (length(idx) > 0) {
    barcode_qc_assay = barcode_qc
    barcode_qc_assay[idx] = paste(barcode_qc_assay[idx], default_assay, sep="_")
    f = barcode_qc_assay %in% colnames(barcode_metadata)
    assertthat::assert_that(all(f),
                            msg=FormatMessage("Cannot find QC {barcode_qc_assay[!f]*} in barcode metadata."))
    barcode_qc = barcode_qc_assay
  }
  return(barcode_qc)
})

# Make plots
plist = PlotBarcodeQCCor(sc, qc=barcode_qc_cor, filter=barcode_filter)

# Prepare captions
captions = GeneratePlotCaptions(names(plist), remove=paste0("_", default_assay), split="__")

# Generate chunks
chunk_template = "
##### {{i}}

\`\`\`{r}
#| label: fig-preprocessing_rna_qc_{{type1}}_vs_{{type2}}
#| fig-asp: 0.7
#| fig-cap: '{{caption}}'
#| echo: false
#| warning: false

print(plist[[{{i}}]])
\`\`\`
"

cat("::: panel-tabset", sep="\n")

for (i in seq(plist)) {
  chunk_filled =  knitr::knit_expand(text=chunk_template, type1=barcode_qc_cor[[i]][1], type2=barcode_qc_cor[[i]][2], i=i, caption=captions[i])
  if(interactive()) {
    EvalKnitrChunk(chunk_filled)
  } else {
    chunk_filled = knitr::knit_child(text=chunk_filled, envir=environment(), quiet=TRUE)
    cat(chunk_filled, sep='\n')
  }
}

cat(":::", sep="\n")
```

### Detailed

```{r}
#| label: preprocess_rna_qc_umap_ridge_plots
#| results: asis

orig_idents = levels(sc$orig.ident)
barcode_metadata = sc[[]]
barcode_filter = PrepareBarcodeFilter(param("barcode_filter"), orig_idents)

# Find barcode QC columns
barcode_qc = param("barcode_qc")
idx = which(!barcode_qc %in% colnames(barcode_metadata))
if (length(idx) > 0) {
  barcode_qc_assay = barcode_qc
  barcode_qc_assay[idx] = paste(barcode_qc_assay[idx], default_assay, sep="_")
  f = barcode_qc_assay %in% colnames(barcode_metadata)
  assertthat::assert_that(all(f),
                          msg=FormatMessage("Cannot find QC {barcode_qc_assay[!f]*} in barcode metadata."))
  barcode_qc = barcode_qc_assay
}

# Make umap plots
Seurat::Idents(sc) = "seurat_clusters"
plist1 = Seurat::FeaturePlot(sc, features=barcode_qc, combine=FALSE, raster=ncol(sc)>=getOption("raster.threshold"))
plist1 = purrr::map(plist1, function(p) {
  p = p + 
    AddPlotStyle() + 
    viridis::scale_colour_viridis(trans="log10")
  p = Seurat::LabelClusters(p, id="ident", fontface="bold", size=5, colour="darkred")
  return(p)
})
names(plist1) = barcode_qc
Seurat::Idents(sc) = "orig.ident"

captions1 = GeneratePlotCaptions(names(plist1), remove=paste0("_", default_assay), capitalize=FALSE)
captions1 = paste("UMAP coloured by", captions1)

# Make ridge plots
plist2 = Seurat::RidgePlot(sc, features=barcode_qc, group.by="seurat_clusters", combine=FALSE, cols=ScColours(sc, "seurat_clusters"))
plist2 = purrr::map(plist2, function(p) {
  p$data = p$data %>% dplyr::filter(!is.na(ident))
  p = p + AddPlotStyle() + theme(legend.position="none")
  return(p)
})
names(plist2) = barcode_qc
captions2 = GeneratePlotCaptions(names(plist2), remove=paste0("_", default_assay), capitalize=TRUE)
captions2 = paste(captions2, "across clusters")

# Set up layout and generate chunks
chunk_template = "
##### {{type}}

::: {layout-ncol=2}

\`\`\`{r}
#| label: fig-preprocessing_rna_qc_umap_{{type}}
#| fig-asp: 0.7
#| fig-cap: '{{caption1}}'
#| echo: false
#| warning: false

print(plist1[[{{i}}]])
\`\`\`

\`\`\`{r}
#| label: fig-preprocessing_rna_qc_ridge_{{type}}
#| fig-asp: 0.7
#| fig-cap: '{{caption2}}'
#| echo: false
#| warning: false

print(plist2[[{{i}}]])
\`\`\`

:::
"

cat("::: panel-tabset", sep="\n")

for (i in seq(barcode_qc)) {
  chunk_filled =  knitr::knit_expand(text=chunk_template, type=barcode_qc[i], i=i, caption1=captions1[i], caption2=captions2[i])
  if(interactive()) {
    EvalKnitrChunk(chunk_filled)
  } else {
    chunk_filled = knitr::knit_child(text=chunk_filled, envir=environment(), quiet=TRUE)
    cat(chunk_filled, sep='\n')
  }
}

cat(":::", sep="\n")
```

## Genes with highest expression

We next investigate whether there are individual genes that are represented by an unusually high number of counts. For each cell, we first calculate the percentage of counts per gene. Subsequently, for each gene, we calculate the median value of these percentages in all cells. Genes with the highest median percentage of counts are plotted below. 

```{r}
#| label: preprocess_rna_highest_genes

orig_idents = levels(sc$orig.ident)
barcode_metadata = sc[[]]
feature_metadata = sc[[default_assay]][[]]

###########
# Overall #
###########

# Get top 20 genes overall
highestExpr = purrr::map_dfr(SeuratObject::Layers(sc, "^counts"), function(l) {
  n = gsub(x=l, pattern="counts\\.", replacement="")

  # Get genes with highest median percentage
  m = paste("medianPerc", n, sep="_")
  idx = order(feature_metadata[, m, drop=TRUE], decreasing=TRUE) %>% head(20)
  highest = feature_metadata[idx, ] %>% 
    tibble::rownames_to_column("gene") %>%
    dplyr::select(median=dplyr::all_of(m), gene)
  highest$orig.ident = n
  return(highest)
})
highestExpr$orig.ident = factor(highestExpr$orig.ident, levels=orig_idents)

# Now rank genes by overall expression
top_genes = highestExpr %>% dplyr::arrange(-median) %>% dplyr::pull(gene) %>% unique()
highestExpr$rank = match(highestExpr$gene, top_genes)
highestExpr$gene = factor(highestExpr$gene, levels=top_genes)

# Collect summary statistics for top 20 genes for each layer (dataset)
highestExpr_summary = purrr::map_dfr(SeuratObject::Layers(sc, "^counts"), function(l) {
  n = gsub(x=l, pattern="counts\\.", replacement="")

  # Get genes with highest median percentage
  m = paste("medianPerc", n, sep="_")
  idx = order(feature_metadata[, m, drop=TRUE], decreasing=TRUE) %>% head(20)
  
  # Get percentages for top 20 genes
  top_counts = sc[[default_assay]][l][idx, ]
  bcs = top_counts %>% colnames()
  total_counts = barcode_metadata[bcs, paste0("nCount_", default_assay), drop=TRUE]
  top_perc = Matrix::t(Matrix::t(top_counts)/total_counts)*100
  
  # Now calculate summary statistics (min, q25, median, mean, q75, max) per feature
  with_progress({
    top_perc_summary = CalculateBoxplotStats(top_perc, margin=1, chunk_size=NULL)
  })
  top_perc_summary$gene = rownames(top_perc_summary)
  rownames(top_perc_summary) = NULL
  top_perc_summary$orig.ident = gsub(x=l, pattern="^counts\\.", replacement="")
  return(top_perc_summary)
})
highestExpr_summary$orig.ident = factor(highestExpr_summary$orig.ident, levels=orig_idents)
```

```{r}
#| label: fig-preprocess_rna_highest_genes
#| fig-cap: "Top 10 highest expressed genes"
#| warning: false

p = ggplot(highestExpr %>% dplyr::filter(rank<=10), aes(x=orig.ident, y=median, col=gene, group=gene)) + 
  geom_point() + 
  AddPlotStyle(title="Highest expression", 
           xlab="Sample", ylab="Median % of raw counts\n per gene", 
           legend_position="bottom") +
  scale_color_manual(values=rev(Seurat::DiscretePalette(n=10, "stepped")))
if (length(orig_idents) > 1) p = p + geom_line()
print(p)
```

```{r}
#| label: preprocess_rna_highest_genes_samples
#| results: asis

orig_idents = levels(sc$orig.ident)

# Make plots
plist = purrr::map(orig_idents, function(s) {
  # Subset data
  plot_data = highestExpr_summary %>% 
    dplyr::filter(orig.ident==s) %>%
    dplyr::arrange(-q50) %>%
    head(20) %>%
    dplyr::arrange(q50)
  plot_data$gene = factor(plot_data$gene, levels=unique(plot_data$gene))

  # Plot
  p = ggplot(plot_data, aes(x=gene, fill=gene)) +
    geom_boxplot(aes(ymin=lower_whisker, lower=q25, middle=q50, upper=q75, ymax=upper_whisker), stat="identity", width=1) +
    scale_x_discrete() +
    scale_y_continuous("% of total counts") +
    scale_fill_manual(values=rev(Seurat::DiscretePalette(n=20, "stepped"))) +
    AddPlotStyle() +
    theme(axis.title.x=element_blank(), legend.position="none") +
    coord_flip()
  
  return(p)
})
names(plist) = orig_idents

# Set up layout and generate chunks

chunk_template = "
##### {{sample}}

\`\`\`{r}
#| label: fig-preprocess_rna_highest_genes_sample_{{sample}}
#| fig-cap: 'Top 10 highest expressed genes for sample {{sample}}'
#| echo: false
#| warning: false

print(plist[[{{i}}]])
\`\`\`
"

cat("::: panel-tabset", sep="\n")

for (i in seq(plist)) {
  chunk_filled =  knitr::knit_expand(text=chunk_template, sample=orig_idents[i], i=i)
  if(interactive()) {
    EvalKnitrChunk(chunk_filled)
  } else {
    chunk_filled = knitr::knit_child(text=chunk_filled, envir=environment(), quiet=TRUE)
    cat(chunk_filled, sep='\n')
  }
}

cat(":::", sep="\n")
```

```{r}
#| label: preprocess_rna_highest_genes_umaps
#| results: asis

top_genes = highestExpr %>% dplyr::pull(gene) %>% levels() %>% head(10)

# Make plots
Seurat::Idents(sc) = "seurat_clusters"
plist = Seurat::FeaturePlot(sc, features=top_genes, raster=ncol(sc)>=getOption("raster.threshold"), combine=FALSE)
Seurat::Idents(sc) = "orig.ident"

plist = purrr::map(plist, function(p) {
  p = p +
    viridis::scale_color_viridis() +
    AddPlotStyle()
  p = Seurat::LabelClusters(p, id="ident", fontface="bold", size=5, colour="darkred")
  return(p)
})
names(plist) = top_genes

# Set up layout and generate chunks
chunk_template = "
##### {{gene}}

\`\`\`{r}
#| label: fig-preprocess_rna_highest_genes_gene_{{gene}}
#| fig-cap: 'Top 10 highest expressed gene {{gene}}'
#| fig-asp: 0.7
#| echo: false
#| warning: false

print(plist[[{{i}}]])
\`\`\`
"

cat("::: panel-tabset", sep="\n")

for (i in seq(plist)) {
  chunk_filled =  knitr::knit_expand(text=chunk_template, gene=top_genes[i], i=i)
  if(interactive()) {
    EvalKnitrChunk(chunk_filled)
  } else {
    chunk_filled = knitr::knit_child(text=chunk_filled, envir=environment(), quiet=TRUE)
    cat(chunk_filled, sep='\n')
  }
}

cat(":::", sep="\n")
```

## Sample QC

```{r}
# sampleqc_data = sc[[]] %>% 
#   dplyr::select(sample_id=orig.ident, 
#                 nCount_RNA=nCount_RNA,
#                 nFeature_RNA=nFeature_RNA,
#                 percent.mt=pMito_RNA)
# sampleqc_data = SampleQC::make_qc_dt(sampleqc_data,
#                      sample_var="sample_id",
#                      qc_names=c("log_counts", "log_feats", "logit_mito"),
#                      annot_vars = NULL)
# 
# 
# # which QC metrics do we want to use?
# qc_names    = c('log_counts', 'log_feats', 'logit_mito')
# 
# # which discrete-valued variables do we want to annotate the samples with?
# annots_disc = NULL
# 
# # which continuous-valued variables do we want to annotate the samples with?
# annots_cont = NULL
# 
# qc_obj    = calc_pairwise_mmds(sampleqc_data, qc_names, 
#   annots_disc = annots_disc, annots_cont = annots_cont, n_cores = 1)
# table(colData(qc_obj)$group_id)

```


## Sample sex

When working with human or animal samples, you should ideally constrain you experiments to a single sex to avoid including sex bias in the conclusions. However this may not always be possible. By looking at reads from chromosomeY (males) and XIST (X-inactive specific transcript) expression (mainly female) it is quite easy to determine per sample which sex it is. It can also bee a good way to detect if there has been any sample mixups, if the sample metadata sex does not agree with the computational predictions. (COPIED)

```{r}
#| label: fig-preprocess_rna_sample_sex_xIST_chrY
#| fig-cap: !expr GeneratePlotCaptions(c("pXIST", "pChrY"))
#| fig-asp: 0.7
#| warning: false

plist = PlotBarcodeQCCor(sc, qc=list(c(paste("pXIST", default_assay, sep="_"), 
                                       paste("pChrY", default_assay, sep="_"))))
print(plist[[1]])
```

`r knitr::asis_output(paste0("::: {layout-ncol=", ifelse(length(orig_idents) <= 10, 2, 1), "}"))`

```{r}
#| label: fig-preprocess_rna_sample_sex_xIST
#| fig-cap: !expr GeneratePlotCaptions("pXIST")
#| fig-asp: 0.5
#| warning: false

plist = PlotBarcodeQC(sc, qc=paste("pXIST", default_assay, sep="_"))
print(plist[[1]])
```

```{r}
#| label: fig-preprocess_rna_sample_sex_chrY
#| fig-cap: !expr GeneratePlotCaptions("pChrY")
#| fig-asp: 0.5
#| warning: false

plist = PlotBarcodeQC(sc, qc=paste("pChrY", default_assay, sep="_"))
print(plist[[1]])
```

:::

## Filtering

Cells and genes are filtered based on the following thresholds: 

```{r}
#| label: tbl-preprocess_rna_barcode_filters
#| tbl-cap: !expr paste("Filters applied to barcodes based on assay", default_assay)

orig_idents = levels(sc$orig.ident)

# Print barcode filters
barcode_filter = PrepareBarcodeFilter(param("barcode_filter"), orig_idents)
barcode_filter_tbl = purrr::map_dfr(names(barcode_filter), function(s) {
  tbl = purrr::map(barcode_filter[[s]], function(f) {
    if (is.numeric(f) & length(f)==2) {
      if (is.na(f[1])) f[1] = ""
      if (is.na(f[2])) f[2] = ""
      return(paste(f, collapse="-"))
    } else {
      return(paste(f, collapse=", "))
    }
  })
  
  if (length(tbl) == 0) {
    tbl = setNames("None", "None")
  }
  
  tbl = data.frame(Sample=s, Filter=names(tbl), Range=unlist(tbl))
  rownames(tbl) = NULL
  return(tbl)
})

gt(barcode_filter_tbl)
```

```{r}
#| label: tbl-preprocess_rna_feature_filters
#| tbl-cap: !expr paste("Filters applied to features of assay", default_assay)

# Print barcode filters
feature_filter = PrepareBarcodeFilter(param("feature_filter"), orig_idents)
feature_filter_tbl = purrr::map_dfr(names(feature_filter), function(s) {
  tbl = purrr::map(feature_filter[[s]], function(f) {
    if (is.numeric(f) & length(f)==2) {
      if (is.na(f[1])) f[1] = ""
      if (is.na(f[2])) f[2] = ""
      return(paste(f, collapse="-"))
    } else {
      return(paste(f, collapse=", "))
    }
  })
  
  if (length(tbl) == 0) {
    tbl = setNames("None", "None")
  }
  
  tbl = data.frame(Sample=s, Filter=names(tbl), Value=unlist(tbl))
  rownames(tbl) = NULL
  return(tbl)
})

gt(feature_filter_tbl)
```

The number of excluded cells and features is as follows: 

```{r}
#| label: tbl-preprocess_rna_filter_barcodes
#| tbl-cap: "Summary of excluded barcodes"

orig_idents = levels(sc$orig.ident)
barcode_filter = PrepareBarcodeFilter(param("barcode_filter"), orig_idents)
barcode_metadata = sc[[]]

# Apply filters to barcodes and record
barcodes_to_exclude = purrr::map(orig_idents, function(s) {
  # Apply user filters
  filter_result = purrr::map(names(barcode_filter[[s]]), function(n) {
    filter = barcode_filter[[s]][[n]]
    if (is.numeric(filter) & length(filter)==2) {
      if (is.na(filter[1])) filter[1] = -Inf
      if (is.na(filter[2])) filter[2] = Inf
      idx_exclude = which(barcode_metadata[[n]] < filter[1] | barcode_metadata[[n]] > filter[2])
    } else {
      idx_exclude = which(!barcode_metadata[[n]] %in% filter)
    }
    return(rownames(barcode_metadata)[idx_exclude])
  })
  names(filter_result) = names(barcode_filter[[s]])
  
  # Samples to drop
  if (s %in% param("samples_to_drop")) {
    idx_exclude = which(barcode_metadata$orig.ident == s)
    filter_result[["samples_to_drop"]] = rownames(barcode_metadata)[idx_exclude]
  } else {
    filter_result[["samples_to_drop"]] = as.character(c())
  }
  
  # Minimum number of cells for a sample to keep
  samples_min_cells = param("samples_min_cells")
  filter_result[["samples_min_cells"]] = as.character(c())
  if (!is.null(samples_min_cells)) {
    idx_exclude = which(barcode_metadata$orig.ident == s)
    if (length(idx_exclude) < samples_min_cells) {
      filter_result[["samples_min_cells"]] = rownames(barcode_metadata)[idx_exclude]
    }
  }
  
  return(filter_result)
})
names(barcodes_to_exclude) = orig_idents

# Summarise
barcodes_to_exclude_tbl = purrr::map_dfr(barcodes_to_exclude, function(s) {
  return(as.data.frame(purrr::map(s, length))) 
  })
rownames(barcodes_to_exclude_tbl) = names(barcodes_to_exclude)
barcodes_to_exclude_tbl$Original = purrr::map_int(orig_idents, function(s) return(sum(barcode_metadata$orig.ident == s)))
barcodes_to_exclude_tbl$Excluded = purrr::map_int(barcodes_to_exclude, function(s) { return(purrr::flatten(s) %>% unique() %>% length())})
barcodes_to_exclude_tbl$PercKept = round((barcodes_to_exclude_tbl$Original - barcodes_to_exclude_tbl$Excluded) / barcodes_to_exclude_tbl$Original * 100, 2)

# Filter
barcodes_to_exclude = purrr::flatten(barcodes_to_exclude) %>% purrr::flatten_chr() %>% unique()
barcodes_to_keep = rownames(barcode_metadata)
barcodes_to_keep = barcodes_to_keep[!barcodes_to_keep %in% barcodes_to_exclude]
sc = subset(sc, cells=barcodes_to_keep)

gt(barcodes_to_exclude_tbl, rownames_to_stub=TRUE)
```

```{r}
#| label: tbl-preprocess_rna_filter_features
#| tbl-cap: "Summary of excluded features"

orig_idents = levels(sc$orig.ident)
feature_filter = PrepareFeatureFilter(param("feature_filter"), orig_idents)
barcode_metadata = sc[[]]
feature_metadata = sc[[default_assay]][[]]

# Iterate over samples and record a feature if it does not pass the filter
features_to_exclude = purrr::map(orig_idents, function(s) {
  l = paste("counts", s, sep=".")
  
  # Get features from layer (dataset)
  features = rownames(sc[[default_assay]][l])
  metadata = feature_metadata[rownames(feature_metadata) %in% features, ]
  
  # Filter
  exclude = metadata[[paste("nBcsThreshold", s, sep="_")]] < feature_filter[[s]][["min_cells"]]
  names(exclude) = rownames(metadata)
  return(exclude)
})
names(features_to_exclude) = orig_idents

# Find features that fail in all samples (get the ones that fail and then apply intersect iteratively)
features_to_exclude_all = purrr::map(features_to_exclude, function(x) return(names(x[x==TRUE]))) %>%
  purrr::reduce(intersect)

# Summarise
features_to_exclude_tbl = purrr::map_dfr(names(features_to_exclude), function(n) {
  # Boolean vector for all features in dataset
  features = features_to_exclude[[n]]
  df = data.frame(Original=length(features), 
                  FailThreshold=sum(features))
  df$PercFailThreshold = round(df$FailThreshold / df$Original * 100, 2)
  
  df$Kept = length(setdiff(names(features), features_to_exclude_all))
  df$PercKept = round(df$Kept / df$Original * 100, 2)
  return(df)
})
rownames(features_to_exclude_tbl) = names(features_to_exclude)

# Remove features
features_to_keep = rownames(sc[[default_assay]])
features_to_keep = features_to_keep[!features_to_keep %in% features_to_exclude_all]
sc[[default_assay]] = suppressWarnings(subset(sc[[default_assay]], features=features_to_keep))

# Feature metadata is not subset correctly
sc[[default_assay]]@meta.data = feature_metadata[features_to_keep, ]
                             
# Print table
gt(features_to_exclude_tbl, rownames_to_stub=TRUE)
```

After filtering, the size of the Seurat object is: 

```{r preprocess_rna_filter_size}
sc
```

## Quality control post filtering

### Overall

The updated QC plots are:

```{r}
#| label: preprocess_rna_postqc_plots
#| results: asis

orig_idents = levels(sc$orig.ident)
barcode_metadata = sc[[]]
barcode_filter = PrepareBarcodeFilter(param("barcode_filter"), orig_idents)

# Find barcode QC columns
barcode_qc = param("barcode_qc")
idx = which(!barcode_qc %in% colnames(barcode_metadata))
if (length(idx) > 0) {
  barcode_qc_assay = barcode_qc
  barcode_qc_assay[idx] = paste(barcode_qc_assay[idx], default_assay, sep="_")
  f = barcode_qc_assay %in% colnames(barcode_metadata)
  assertthat::assert_that(all(f),
                          msg=FormatMessage("Cannot find QC {barcode_qc_assay[!f]*} in barcode metadata."))
  barcode_qc = barcode_qc_assay
}

# Make plots
plist = PlotBarcodeQC(sc, qc=barcode_qc, filter=barcode_filter)

# Prepare captions
captions = GeneratePlotCaptions(names(plist), remove=paste0("_", default_assay))
captions = paste(captions, "(filtered)")

# Setup layout and generate chunks
chunk_template = "
\`\`\`{r}
#| label: fig-preprocessing_rna_postqc_{{type}}
#| fig-asp: 0.5
#| fig-cap: '{{caption}}'
#| echo: false
#| warning: false

print(plist[[{{i}}]])
\`\`\`
"

if (length(orig_idents) <= 10) {
  cat("::: {layout-ncol=2}", sep="\n")
} else {
  cat("::: {layout-ncol=1}", sep="\n")
}

for (i in seq(plist)) {
  chunk_filled =  knitr::knit_expand(text=chunk_template, type=barcode_qc[i], i=i, caption=captions[i])
  if(interactive()) {
    EvalKnitrChunk(chunk_filled)
  } else {
    chunk_filled = knitr::knit_child(text=chunk_filled, envir=environment(), quiet=TRUE)
    cat(chunk_filled, sep='\n')
  }
}

cat(":::", sep="\n")
```


```{r}
#| label: preprocess_rna_postqc_cor_plots
#| results: asis

orig_idents = levels(sc$orig.ident)
barcode_metadata = sc[[]]
barcode_filter = PrepareBarcodeFilter(param("barcode_filter"), orig_idents)

# Find barcode QC columns
barcode_qc_cor = strsplit(param("barcode_qc_cor"), "\\s+")
barcode_qc_cor = purrr::map(barcode_qc_cor, function(barcode_qc) {
  idx = which(!barcode_qc %in% colnames(barcode_metadata))
  if (length(idx) > 0) {
    barcode_qc_assay = barcode_qc
    barcode_qc_assay[idx] = paste(barcode_qc_assay[idx], default_assay, sep="_")
    f = barcode_qc_assay %in% colnames(barcode_metadata)
    assertthat::assert_that(all(f),
                            msg=FormatMessage("Cannot find QC {barcode_qc_assay[!f]*} in barcode metadata."))
    barcode_qc = barcode_qc_assay
  }
  return(barcode_qc)
})

# Make plots
plist = PlotBarcodeQCCor(sc, qc=barcode_qc_cor, filter=barcode_filter)

# Prepare captions
captions = GeneratePlotCaptions(names(plist), remove=paste0("_", default_assay), split="__")

# Generate chunks
chunk_template = "
##### {{i}}

\`\`\`{r}
#| label: fig-preprocessing_rna_postqc_{{type1}}_vs_{{type2}}
#| fig-asp: 0.7
#| fig-cap: '{{caption}}'
#| echo: false
#| warning: false

print(plist[[{{i}}]])
\`\`\`
"

cat("::: panel-tabset", sep="\n")

for (i in seq(plist)) {
  chunk_filled =  knitr::knit_expand(text=chunk_template, type1=barcode_qc_cor[[i]][1], type2=barcode_qc_cor[[i]][2], i=i, caption=captions[i])
  if(interactive()) {
    EvalKnitrChunk(chunk_filled)
  } else {
    chunk_filled = knitr::knit_child(text=chunk_filled, envir=environment(), quiet=TRUE)
    cat(chunk_filled, sep='\n')
  }
}

cat(":::", sep="\n")
```

### Detailed

```{r}
#| label: preprocess_rna_postqc_umap_ridge_plots
#| results: asis

orig_idents = levels(sc$orig.ident)
barcode_metadata = sc[[]]
barcode_filter = PrepareBarcodeFilter(param("barcode_filter"), orig_idents)

# Find barcode QC columns
barcode_qc = param("barcode_qc")
idx = which(!barcode_qc %in% colnames(barcode_metadata))
if (length(idx) > 0) {
  barcode_qc_assay = barcode_qc
  barcode_qc_assay[idx] = paste(barcode_qc_assay[idx], default_assay, sep="_")
  f = barcode_qc_assay %in% colnames(barcode_metadata)
  assertthat::assert_that(all(f),
                          msg=FormatMessage("Cannot find QC {barcode_qc_assay[!f]*} in barcode metadata."))
  barcode_qc = barcode_qc_assay
}

# Make umap plots
Seurat::Idents(sc) = "seurat_clusters"
plist1 = Seurat::FeaturePlot(sc, features=barcode_qc, combine=FALSE, raster=ncol(sc)>=getOption("raster.threshold"))
plist1 = purrr::map(plist1, function(p) {
  p = p + 
    AddPlotStyle() + 
    viridis::scale_colour_viridis(trans="log10")
  p = Seurat::LabelClusters(p, id="ident", fontface="bold", size=5, colour="darkred")
  return(p)
})
names(plist1) = barcode_qc
Seurat::Idents(sc) = "orig.ident"

captions1 = GeneratePlotCaptions(names(plist1), remove=paste0("_", default_assay), capitalize=FALSE)
captions1 = paste("UMAP coloured by", captions1)

# Make ridge plots
plist2 = Seurat::RidgePlot(sc, features=barcode_qc, group.by="seurat_clusters", combine=FALSE, cols=ScColours(sc, "seurat_clusters"))
plist2 = purrr::map(plist2, function(p) {
  p$data = p$data %>% dplyr::filter(!is.na(ident))
  p = p + AddPlotStyle() + theme(legend.position="none")
  return(p)
})
names(plist2) = barcode_qc
captions2 = GeneratePlotCaptions(names(plist2), remove=paste0("_", default_assay), capitalize=TRUE)
captions2 = paste(captions2, "across clusters")

# Set up layout and generate chunks
chunk_template = "
##### {{type}}

::: {layout-ncol=2}

\`\`\`{r}
#| label: fig-preprocessing_rna_postqc_umap_{{type}}
#| fig-asp: 0.7
#| fig-cap: '{{caption1}}'
#| echo: false
#| warning: false

print(plist1[[{{i}}]])
\`\`\`

\`\`\`{r}
#| label: fig-preprocessing_rna_postqc_ridge_{{type}}
#| fig-asp: 0.7
#| fig-cap: '{{caption2}}'
#| echo: false
#| warning: false

print(plist2[[{{i}}]])
\`\`\`

:::
"

cat("::: panel-tabset", sep="\n")

for (i in seq(barcode_qc)) {
  chunk_filled =  knitr::knit_expand(text=chunk_template, type=barcode_qc[i], i=i, caption1=captions1[i], caption2=captions2[i])
  if(interactive()) {
    EvalKnitrChunk(chunk_filled)
  } else {
    chunk_filled = knitr::knit_child(text=chunk_filled, envir=environment(), quiet=TRUE)
    cat(chunk_filled, sep='\n')
  }
}

cat(":::", sep="\n")
```

## Cell Cycle

```{r}
#| label: preprocess_rna_cell_cycle

#########################
# Find cell-cycle genes #
#########################

species = param("species")
ensembl_version = param("ensembl")
barcode_metadata = sc[[]]
feature_metadata = sc[[default_assay]][[]]

# These are the human cell cycle genes
seurat_s_genes = Seurat::cc.genes.updated.2019[["s.genes"]]
seurat_g2m_genes = Seurat::cc.genes.updated.2019[["g2m.genes"]]

# Find the correct features
ensembl_column = NULL
if ("ensembl_id" %in% colnames(feature_metadata)) {
  ensembl_column = "ensembl_id"
} else if (any(grepl("^ENS", feature_metadata[["feature_id"]]))) {
  ensembl_column = "feature_id"
}

if (!is.null(ensembl_column) & !is.null(ensembl_version)) {
  # Use Ensembl
  if (species != "homo_sapiens") {
    # Fetch one-to-one orthologues via Ensembl
    seurat_s_genes = EnsemblFetchOrthologues(ids=seurat_s_genes,
                                          symbols=TRUE,
                                          species1="homo_sapiens",
                                          species2=species,
                                          ensembl_version=ensembl_version,
                                          mart_attributes1=c(ensembl_id1="ensembl_gene_id", 
                                                            ensembl_symbol1="external_gene_name"),
                                          mart_attributes2=c(ensembl_id2="ensembl_gene_id", 
                                                            ensembl_symbol2="external_gene_name"),
                                          useCache=TRUE)
    seurat_s_genes = seurat_s_genes %>% dplyr::filter(one_to_one == TRUE) %>% dplyr::pull(ensembl_id2)
    
    seurat_g2m_genes = EnsemblFetchOrthologues(ids=seurat_g2m_genes,
                                          symbols=TRUE,
                                          species1="homo_sapiens",
                                          species2=species,
                                          ensembl_version=ensembl_version,
                                          mart_attributes1=c(ensembl_id1="ensembl_gene_id", 
                                                            ensembl_symbol1="external_gene_name"),
                                          mart_attributes2=c(ensembl_id2="ensembl_gene_id", 
                                                            ensembl_symbol2="external_gene_name"),
                                          useCache=TRUE)
    seurat_g2m_genes = seurat_s_genes %>% dplyr::filter(one_to_one == TRUE) %>% dplyr::pull(ensembl_id2)
  } else {
    # Fetch ids via Ensembl
    seurat_s_genes = EnsemblFetchGeneInfo(ids=seurat_s_genes,
                                          symbols=TRUE,
                                          species=species,
                                          ensembl_version=ensembl_version,
                                          mart_attributes=c(ensembl_id="ensembl_gene_id", 
                                                            ensembl_symbol="external_gene_name"),
                                          useCache=TRUE)
    seurat_s_genes = seurat_s_genes %>% dplyr::filter(!is.na(ensembl_id)) %>% dplyr::pull(ensembl_id)
    
    seurat_g2m_genes = EnsemblFetchGeneInfo(ids=seurat_g2m_genes,
                                          symbols=TRUE,
                                          species=species,
                                          ensembl_version=ensembl_version,
                                          mart_attributes=c(ensembl_id="ensembl_gene_id", 
                                                            ensembl_symbol="external_gene_name"),
                                          useCache=TRUE)
    seurat_g2m_genes = seurat_g2m_genes %>% dplyr::filter(!is.na(ensembl_id)) %>% dplyr::pull(ensembl_id)
  }
  
  # Subset feature names
  idx = which(feature_metadata[, ensembl_column, drop=TRUE] %in% seurat_s_genes)
  seurat_s_genes = rownames(feature_metadata)[idx]
  
  idx = which(feature_metadata[, ensembl_column, drop=TRUE] %in% seurat_g2m_genes)
  seurat_g2m_genes = rownames(feature_metadata)[idx]
} else {
  # Do not use Ensembl
  
  # Simply match while ignoring case
  idx = which(toupper(rownames(feature_metadata)) %in% topupper(seurat_s_genes))
  seurat_s_genes = rownames(feature_metadata)[idx]
  
  idx = which(toupper(rownames(feature_metadata)) %in% topupper(seurat_g2m_genes))
  seurat_g2m_genes = rownames(feature_metadata)[idx]
}

# Add to Seurat object
sc = ScAddLists(sc, lists=list(CC_S_phase=seurat_s_genes, CC_G2M_phase=seurat_g2m_genes), lists_slot="gene_lists")

###############################
# Calculate cell-cycle scores #
###############################

# Calculate scores
sc = CCScoring(sc, genes_s=seurat_s_genes, genes_g2m=seurat_g2m_genes)
```

### Overall

```{r}
#| label: tbl-preprocess_rna_cell_cycle_summary
#| tbl-cap: "Cell cycle summary"

barcode_metadata = sc[[]]

# Print a summary table
cell_cycle_summary_tbl = barcode_metadata %>% 
  dplyr::count(orig.ident, Phase) %>%
  tidyr::pivot_wider(names_from=Phase, values_from=n, values_fill=0)

gt(cell_cycle_summary_tbl, rowname_col="orig.ident")
```

```{r}
#| label: fig-preprocess_rna_cell_cycle_S_G2M
#| fig-cap: !expr GeneratePlotCaptions(c("S.Score", "G2M.Score"))
#| fig-asp: 0.7
#| warning: false

plist = PlotBarcodeQCCor(sc, qc=list(c("S.Score", "G2M.Score")))
print(plist[[1]])
```

`r knitr::asis_output(paste0("::: {layout-ncol=", ifelse(length(orig_idents) <= 10, 2, 1), "}"))`

```{r}
#| label: fig-preprocess_rna_cell_cycle_S
#| fig-cap: !expr GeneratePlotCaptions("S.Score")
#| fig-asp: 0.5
#| warning: false

plist = PlotBarcodeQC(sc, qc="S.Score")
print(plist[[1]])
```
```{r}
#| label: fig-preprocess_rna_cell_cycle_G2M
#| fig-cap: !expr GeneratePlotCaptions("G2M.Score")
#| fig-asp: 0.5
#| warning: false

plist = PlotBarcodeQC(sc, qc="G2M.Score")
print(plist[[1]])
```

:::

### Detailed

```{r}
#| label: preprocess_rna_cell_cycle_umap_plots
#| results: asis

orig_idents = levels(sc$orig.ident)
barcode_metadata = sc[[]]

# Make umap plots
plist1 = Seurat::DimPlot(sc, group.by=c("Phase"), combine=FALSE, raster=ncol(sc)>=getOption("raster.threshold"))
plist1 = purrr::map(plist1, function(p) {
  p$data$ident = barcode_metadata[rownames(p$data), "seurat_clusters"]
  p = p + 
    AddPlotStyle()
  p = Seurat::LabelClusters(p, id="ident", fontface="bold", size=5, colour="darkred")
  return(p)
})
names(plist1) = c("Phase")

plist2 = Seurat::FeaturePlot(sc, features=c("S.Score", "G2M.Score"), combine=FALSE, raster=ncol(sc)>=getOption("raster.threshold"))
plist2 = purrr::map(plist2, function(p) {
  p$data$ident = barcode_metadata[rownames(p$data), "seurat_clusters"]
  p = p + 
    AddPlotStyle() + 
    theme(legend.position="none") + 
    viridis::scale_colour_viridis(trans="log10")
  p = Seurat::LabelClusters(p, id="ident", fontface="bold", size=5, colour="darkred")
  return(p)
})
names(plist2) = c("S.Score", "G2M.Score")

plist = c(plist1, plist2)
cell_cycle_qc = names(plist)
captions = paste("UMAP coloured by", c("cell cycle phase", "S score", "G2M score"))

# Set up layout and generate chunks
chunk_template = "
##### {{type}}

\`\`\`{r}
#| label: fig-preprocessing_rna_cell_cycle_umap_{{type}}
#| fig-asp: 0.7
#| fig-cap: '{{caption}}'
#| echo: false
#| warning: false

print(plist[[{{i}}]])
\`\`\`
"

cat("::: panel-tabset", sep="\n")

for (i in seq(cell_cycle_qc)) {
  chunk_filled =  knitr::knit_expand(text=chunk_template, type=cell_cycle_qc[i], i=i, caption=captions[i])
  if(interactive()) {
    EvalKnitrChunk(chunk_filled)
  } else {
    chunk_filled = knitr::knit_child(text=chunk_filled, envir=environment(), quiet=TRUE)
    cat(chunk_filled, sep='\n')
  }
}

cat(":::", sep="\n")
```

## Save Seurat object

```{r}
#| label: preprocess_rna_save_seurat

# Dump the layers with the normalized data for now (will be done in another module)
layers = SeuratObject::Layers(sc, search="^data")
for(i in seq_along(layers)) {
  SeuratObject::LayerData(sc[[default_assay]], layer=layers[i]) = NULL
}

# Dump the Sketch assay for now
sc[[paste0(default_assay, "Sketch")]] = NULL

# Dump the dimensionality reductions for now
sc[["pca"]] = NULL
sc[["umap"]] = NULL
if ("integrated.cca" %in% SeuratObject::Reductions(sc)) sc[["integrated.cca"]] = NULL

# Dump the clustering for now
sc$seurat_clusters = NULL

# Save Seurat object and layer data
with_progress({
  SaveSeuratRds_Custom(sc,
              outdir=file.path(module_dir, "sc"))
})
```



