---
# Module-specific parameters (that are not already in the profile yaml)
params:
  # Name of the module used in configurations
  module: "preprocessing_rna"
    
  # Relative path to the module directory (which contains the qmd file)
  module_dir: "modules/2_preprocessing/rna"
  
  # Path to previous module. If null, will be read from the 'chapters' entry in the profile yaml
  prev_module_dir: null
  
  # Default assay.
  default_assay: RNA
  
  # Filter for cells and nuclei
  barcode_filter: !expr list(
    nCount_RNA = c(1000, NA),
    nFeature_RNA = c(400, 4000),
    Type = c("A", "B"))

  # Filter for features
  feature_filter: !expr list(
    min_counts = 1,
    min_cells = 3)
    
  # List of samples to drop after initial QC. Set to 'null' for an empty list.
  # Example:
  #  - sampleA
  #  - sampleB
  samples_to_drop: null

  # Drop samples with too few cells
  samples_min_cells: 10
  
# Module execution
execute:
  # Should this module be frozen and never re-rendered?
  # - auto: if the code has not changed (default)
  # - true/false: freeze/re-render
  # Does not apply in interactive mode or when explicitly rendering this document via in rstudio
  freeze: auto
---

# Preprocessing (RNA)

## Overview

In this chapter, we read in counts data as "features x barcodes" matrices. If provided, we read in additional metadata for features and barcodes. For spatial data, we additionally read in the image data. All data is imported into an Seurat object. Basic summary stats are calculated and shown. Finally, the Seurat object is saved for further processing in the next chapters.

```{r}
#| label: setup
#| message: false
#| warning: false

# If running code interactively in rstudio, set profile here
# When rendering with quarto, profile is already set and should not be overwritten
if (nchar(Sys.getenv("QUARTO_PROFILE")) == 0) {Sys.setenv("QUARTO_PROFILE" = "default")}

# Source general configurations (always)
source("R/general_configuration.R")

# Source required R functions
source("R/functions_util.R")
source("R/functions_io.R")
source("R/functions_plotting.R")

# Load libraries
library(knitr)
library(magrittr)
library(gt)
library(Seurat)
library(ggplot2)

# Get module name and directory (needed to access files within the module directory)
module_name = params$module_name
module_dir = params$module_dir
```

```{r}
#| label: preprocess_rna_preparation

###############
# Directories #
###############

# Module directory 'results' contains all output that should be provided together with the final report of the project
dir.create(file.path(module_dir, "results"), showWarnings=FALSE)

# Module directory 'tmp' contains all intermediate files only used for this module
dir.create(file.path(module_dir, "tmp"), showWarnings=FALSE)

# Only if counts are stored on disk: module directory 'counts' contains counts for all datasets and assays
dir.create(file.path(module_dir, "counts"), showWarnings=FALSE)

#################
# Seurat object #
#################

# Read in seurat object
if (!is.null(param("prev_module_dir"))) {
  prev_module_dir = param("prev_module_dir")
} else {
  prev_module_dir = PreviousModuleDir(module_dir)
}
prev_sc_obj = file.path(prev_module_dir, "sc", "sc.rds")
if(!file.exists(prev_sc_obj)) {
  stop(FormatMessage("Could not find a sc.rds file in {{prev_module_dir}}. Was the respective module already run?"))
}
sc = readRDS(prev_sc_obj)
default_assay = param("default_assay")
Seurat::DefaultAssay(sc) = default_assay

# We already apply a basic normalization
sc = Seurat::NormalizeData(sc, assay=default_assay, normalization.method="LogNormalize", scale.factor=10000, verbose=FALSE)
```


## Basic quality control 

```{r}
#| label: preprocess_rna_qc_barcodes
#| timeit: true

############
# Barcodes #
############

barcode_metadata = sc[[]]
feature_metadata = sc[[default_assay]][]

# Calculate percentage of counts in mitochondrial genes
mt_features = grep(pattern="^MT-", x=rownames(feature_metadata), value=TRUE, ignore.case=TRUE)
sc[[paste("pMito", default_assay, sep="_")]] = PercentageFeatureSet(object=sc, features=mt_features)

# Calculate percentage of counts in ribosomal genes
ribo_features = grep(pattern="^RP[SL]", x=rownames(feature_metadata), value=TRUE, ignore.case=TRUE)
sc[[paste("pRibosomal", default_assay, sep="_")]] = PercentageFeatureSet(object=sc, features=ribo_features)

# Calculate percentage of counts in globin genes
globin_features = grep("^HB[ABDGEMQZ]", x=rownames(feature_metadata), value=TRUE, ignore.case=TRUE)
sc[[paste("pGlobin", default_assay, sep="_")]] = PercentageFeatureSet(object=sc, features=globin_features)

# Calculate percentage of counts in globin genes
ercc_features = grep("^ERCC-", x=rownames(feature_metadata), value=TRUE, ignore.case=TRUE)
sc[[paste("pERCC", default_assay, sep="_")]] = PercentageFeatureSet(object=sc, features=ercc_features)

# Calculate number of counts in XIST
xist_feature = grep("^XIST", x=rownames(feature_metadata), value=TRUE, ignore.case=TRUE)
sc[[paste("pXIST", default_assay, sep="_")]] = PercentageFeatureSet(object=sc, features=xist_feature)

# Calculate percentage of counts in chrY genes
sc[[paste("pChrY", default_assay, sep="_")]] = 0
if ("ensembl_chr" %in% colnames(feature_metadata)) {
  chrY_features = which(feature_metadata$ensembl_chr %in% c("chrY", "Y"))
  sc[[paste("pChrY", default_assay, sep="_")]] = PercentageFeatureSet(object=sc, features=chrY_features)
}

```

```{r}
#| label: preprocess_rna_qc_features
#| timeit: true

############
# Features #
############

orig_idents = levels(sc$orig.ident)
feature_filter = PrepareFeatureFilter(param("feature_filter"), orig_idents)

# Calculate number of barcodes above threshold for each layer (dataset)
for (l in SeuratObject::Layers(sc, "counts")) {
  n = gsub(x=l, pattern="counts\\.", replacement="")

  # Get data for layer (sample) and count
  counts = sc[[default_assay]][[l]]
  num_bcs_expr = rowSums(counts >= feature_filter[[n]]$min_counts)
  
  # Add to metadata
  sc[[default_assay]][paste("nBcsThreshold", n, sep="_")] = num_bcs_expr
}

```

```{r}
#| label: preprocess_rna_qc_plots
#| results: asis

orig_idents = levels(sc$orig.ident)
barcode_filter = PrepareBarcodeFilter(param("barcode_filter"), orig_idents)

# QC metrics to plot for cells
qc_features = paste(c("nCount", "nFeature", "pCountsTop50", "pMito"), default_assay, sep="_")
captions = paste(default_assay, c("Number of counts per barcode", "Number of features per barcode", "Percent counts in top50 features", "Percent counts in mitochondrial genes"), sep=": ")

if (sum(sc[[paste("pERCC", default_assay, sep="_")]]) > 0) {
  qc_features = c(qc_features, paste(c("pERCC"), default_assay, sep="_"))
  captions = c(captions, paste(default_assay, c("Percent counts in ERCC controls"), sep=": "))
}

# Get filter thresholds per QC metrics (for plotting)
qc_thresholds = purrr::map(qc_features, function(f) {
  tresh = purrr::map_dfr(names(barcode_filter), function(n) {
    tr = data.frame(qc_feature=character(), ident=character(), min=numeric(), max=numeric())
    if (f %in% names(barcode_filter[[n]])) {
      tr = data.frame(qc_feature=f, ident=n, min=barcode_filter[[n]][[f]][1], max=barcode_filter[[n]][[f]][2])
    }
    tr$ident = factor(tr$ident, levels=orig_idents)
    tr = tr %>% tidyr::pivot_longer(c(min, max), names_to="threshold", values_to="value")
    return(tr)
  })
})
names(qc_thresholds) = qc_features

# Make plots
plist = Seurat::VlnPlot(sc, features=qc_features, combine=FALSE, pt.size=0, raster=FALSE)
names(plist) = qc_features
plist = purrr::map(seq(plist), function(i) {
  p = plist[[i]]

  # Add style
  p = p + AddPlotStyle(legend_position="none", xlab="") +
    theme(axis.text.x=element_text(angle=45, hjust=1))
  
  # Add filter thresholds
  qc_threshold_segments = purrr::pmap(qc_thresholds[[i]], function(qc_feature, ident, threshold, value) {
    return(annotate(geom="segment", x=as.integer(ident)-0.5, xend=as.integer(ident)+0.5, y=value, yend=value, linetype=ifelse(threshold=="max", 6, 2), colour="firebrick"))
  })
  p = p + qc_threshold_segments
  return(p)
})

# Generate chunks
chunk_template = "
\`\`\`{r}
#| label: fig-preprocessing_rna_qc_{{type}}
#| fig-asp: 0.5
#| fig-cap: '{{caption}}'
#| echo: false
#| warning: false

print(plist[[{{i}}]])
\`\`\`
"

for (i in seq(plist)) {
  chunk_filled =  knitr::knit_expand(text=chunk_template, type=qc_features[i], i=i, caption=captions[i])
  if(interactive()) {
    EvalKnitrChunk(chunk_filled)
  } else {
    chunk_filled = knitr::knit_child(text=chunk_filled, envir=environment(), quiet=TRUE)
    cat(chunk_filled, sep='\n')
  }
}
```

```{r}
#| label: preprocess_rna_qc_cor_plots
#| results: asis

orig_idents = levels(sc$orig.ident)
barcode_filter = PrepareBarcodeFilter(param("barcode_filter"), orig_idents)

# Correlate QC metrics for cells
qc_feature_cors = list(
  paste(c("nFeature", "nCount"), default_assay, sep="_"),
  paste(c("nFeature", "pMito"), default_assay, sep="_")
)
captions = c("Number of features vs number of counts", "Number of features vs number of counts in mitochondrial genes")

if (sum(sc[[paste("pERCC", default_assay, sep="_")]]) > 0) {
  qc_feature_cors = c(qc_feature_cors, paste(c("nFeature", "pERCC"), default_assay, sep="_"))
  captions = c(captions, paste(default_assay, c("Number of features vs number of counts in ERCC controls"), sep=": "))
}

# Get filter thresholds per QC metrics (for plotting)
qc_thresholds = purrr::map(qc_features, function(f) {
  tresh = purrr::map_dfr(names(barcode_filter), function(n) {
    tr = data.frame(qc_feature=character(), ident=character(), min=numeric(), max=numeric())
    if (f %in% names(barcode_filter[[n]])) {
      tr = data.frame(qc_feature=f, ident=n, min=barcode_filter[[n]][[f]][1], max=barcode_filter[[n]][[f]][2])
    }
    tr$ident = factor(tr$ident, levels=orig_idents)
    tr = tr %>% tidyr::pivot_longer(c(min, max), names_to="threshold", values_to="value")
    return(tr)
  })
})
names(qc_thresholds) = qc_features

# Make plots
plist = purrr::map(qc_feature_cors, function(c) {
  f1 = c[1]
  f2 = c[2]
  
  # Plot QC feature f1 vs f2
  p = Seurat::FeatureScatter(sc, feature1=f1, feature2=f2, shuffle=TRUE, seed=getOption("random_seed"), raster=ncol(sc)>=getOption("raster.threshold"))
  p = p + AddPlotStyle()
  
  # Add filter thresholds for f1
  qc_threshold_segments = purrr::pmap(qc_thresholds[[f1]], function(qc_feature, ident, threshold, value) {
      return(geom_vline(xintercept=value, linetype=ifelse(threshold=="max", 6, 2), colour="firebrick"))
  })
  p = p + qc_threshold_segments
  
  # Add filter thresholds for f2
  qc_threshold_segments = purrr::pmap(qc_thresholds[[f2]], function(qc_feature, ident, threshold, value) {
      return(geom_hline(yintercept=value, linetype=ifelse(threshold=="max", 6, 2), colour="firebrick"))
  })
  p = p + qc_threshold_segments
  
  return(p)
})

# Generate chunks
chunk_template = "
\`\`\`{r}
#| label: fig-preprocessing_rna_qc_{{type1}}_vs_{{type2}}
#| fig-asp: 0.5
#| fig-cap: '{{caption}}'
#| echo: false
#| warning: false

print(plist[[{{i}}]])
\`\`\`
"

for (i in seq(plist)) {
  chunk_filled =  knitr::knit_expand(text=chunk_template, type1=qc_feature_cors[[i]][1], type2=qc_feature_cors[[i]][2], i=i, caption=captions[i])
  if(interactive()) {
    EvalKnitrChunk(chunk_filled)
  } else {
    chunk_filled = knitr::knit_child(text=chunk_filled, envir=environment(), quiet=TRUE)
    cat(chunk_filled, sep='\n')
  }
}
```


## Genes with highest expression

We next investigate whether there are individual genes that are represented by an unusually high number of counts. For each cell, we first calculate the percentage of counts per gene. Subsequently, for each gene, we calculate the median value of these percentages in all cells. Genes with the highest median percentage of counts are plotted below. 

```{r}
#| label: preprocess_rna_highest_expr

orig_idents = levels(sc$orig.ident)
barcode_metadata = sc[[]]
feature_metadata = sc[[default_assay]][]

###########
# Overall #
###########

# Get top 20 genes overall
highestExpr = purrr::map_dfr(SeuratObject::Layers(sc, "counts"), function(l) {
  n = gsub(x=l, pattern="counts\\.", replacement="")

  # Get genes with highest median percentage
  m = paste("medianPerc", n, sep="_")
  idx = order(feature_metadata[, m, drop=TRUE], decreasing=TRUE) %>% head(20)
  highest = feature_metadata[idx, ] %>% 
    tibble::rownames_to_column("gene") %>%
    dplyr::select(median=dplyr::all_of(m), gene)
  highest$orig.ident = n
  return(highest)
})
highestExpr$orig.ident = factor(highestExpr$orig.ident, levels=orig_idents)

# Now rank genes by overall expression
top_genes = highestExpr %>% dplyr::arrange(-median) %>% dplyr::pull(gene) %>% unique()
highestExpr$rank = match(highestExpr$gene, top_genes)
highestExpr$gene = factor(highestExpr$gene, levels=top_genes)

# Collect summary statistics for top 20 genes for each layer (dataset)
highestExpr_summary = purrr::map_dfr(SeuratObject::Layers(sc, "counts"), function(l) {
  n = gsub(x=l, pattern="counts\\.", replacement="")

  # Get genes with highest median percentage
  m = paste("medianPerc", n, sep="_")
  idx = order(feature_metadata[, m, drop=TRUE], decreasing=TRUE) %>% head(20)
  
  # Get percentages for top 20 genes
  top_counts = sc[[default_assay]][[l]][idx, ]
  bcs = top_counts %>% colnames()
  total_counts = barcode_metadata[bcs, paste0("nCount_", default_assay), drop=TRUE]
  top_perc = Matrix::t(Matrix::t(top_counts)/total_counts)*100
  
  # Now calculate summary statistics (min, q25, median, mean, q75, max) per feature
  top_perc = as(top_perc, "dgCMatrix")
  top_perc_summary = purrr::map(1:nrow(top_perc), function(i) {
    return(summary(top_perc[i, ]))
  })
  top_perc_summary = do.call(rbind, top_perc_summary) %>% as.data.frame()
  colnames(top_perc_summary) = c("min", "q25", "median", "mean", "q75", "max")
  top_perc_summary$gene = rownames(top_perc)
  top_perc_summary$orig.ident = gsub(x=l, pattern="^counts\\.", replacement="")
  return(top_perc_summary)
})
highestExpr_summary$orig.ident = factor(highestExpr_summary$orig.ident, levels=orig_idents)
```

```{r}
#| label: fig-preprocess_rna_highest_expr_genes
#| fig-cap: "Top 10 highest expressed genes"
#| warning: false

p = ggplot(highestExpr %>% dplyr::filter(rank<=10), aes(x=orig.ident, y=median, col=gene, group=gene)) + 
  geom_point() + 
  AddPlotStyle(title="Highest expression", 
           xlab="Sample", ylab="Median % of raw counts\n per gene", 
           legend_position="bottom") +
  scale_color_manual(values=rev(Seurat::DiscretePalette(n=10, "stepped")))
if (length(orig_idents) > 1) p = p + geom_line()
print(p)
```

::: panel-tabset
```{r}
#| label: preprocess_rna_highest_expr_genes_samples
#| results: asis

orig_idents = levels(sc$orig.ident)

# Make plots
plist = purrr::map(orig_idents, function(s) {
  # Subset data
  plot_data = highestExpr_summary %>% 
    dplyr::filter(orig.ident==s) %>%
    dplyr::arrange(-median) %>%
    head(20) %>%
    dplyr::arrange(median)
  plot_data$gene = factor(plot_data$gene, levels=unique(plot_data$gene))

  # Plot
  p = ggplot(plot_data, aes(x=gene, fill=gene)) +
    geom_boxplot(aes(ymin=min, lower=q25, middle=median, upper=q75, ymax=max), stat="identity", width=1) +
    scale_x_discrete() +
    scale_y_continuous("% of total counts") +
    scale_fill_manual(values=rev(Seurat::DiscretePalette(n=20, "stepped"))) +
    AddPlotStyle() +
    theme(axis.title.x=element_blank(), legend.position="none") +
    coord_flip()
  
  return(p)
})
names(plist) = orig_idents

# Generate chunks

chunk_template = "
##### {{sample}}

\`\`\`{r}
#| label: fig-preprocess_rna_highest_expr_genes_{{sample}}
#| fig-cap: 'Top 10 highest expressed genes for sample {{sample}}'
#| echo: false
#| warning: false

print(plist[[{{i}}]])
\`\`\`
"

for (i in seq(plist)) {
  chunk_filled =  knitr::knit_expand(text=chunk_template, sample=orig_idents[i], i=i)
  if(interactive()) {
    EvalKnitrChunk(chunk_filled)
  } else {
    chunk_filled = knitr::knit_child(text=chunk_filled, envir=environment(), quiet=TRUE)
    cat(chunk_filled, sep='\n')
  }
}

```
:::

## Sample sex

When working with human or animal samples, you should ideally constrain you experiments to a single sex to avoid including sex bias in the conclusions. However this may not always be possible. By looking at reads from chromosomeY (males) and XIST (X-inactive specific transcript) expression (mainly female) it is quite easy to determine per sample which sex it is. It can also bee a good way to detect if there has been any sample mixups, if the sample metadata sex does not agree with the computational predictions. (COPIED)

```{r}
#| label: fig-preprocess_rna_sample_sex
#| fig-cap: 
#|   - "Percent XIST gene vs chrY genes"
#|   - "Percent XIST gene"
#|   - "Percent chrY gene"
#| warning: false

p = Seurat::FeatureScatter(sc, feature1=paste("pXIST", default_assay, sep="_"), feature2=paste("pChrY", default_assay, sep="_"), shuffle=TRUE, plot.cor=FALSE, raster=ncol(sc)>=getOption("raster.threshold"))
p = p + 
  AddPlotStyle()
print(p)

plist = Seurat::VlnPlot(sc, features=c(paste("pXIST", default_assay, sep="_"), paste("pChrY", default_assay, sep="_")), pt.size=0, raster=FALSE, combine=FALSE)
plist = purrr::map(plist, function(p) return(p + AddPlotStyle() + theme(legend.position="none")))
print(plist)
```

## Filtering

Cells and genes are filtered based on the following thresholds: 

```{r}
#| label: tbl-preprocess_rna_barcode_filters
#| tbl-cap: !expr paste("Filters applied to barcodes based on assay", default_assay)

# Print barcode filters
orig_idents = levels(sc$orig.ident)
barcode_filter = PrepareBarcodeFilter(param("barcode_filter"), orig_idents)
barcode_filter_tbl = purrr::map_dfr(names(barcode_filter), function(s) {
  tbl = purrr::map(barcode_filter[[s]], function(f) {
    if (is.numeric(f) & length(f)==2) {
      if (is.na(f[1])) f[1] = ""
      if (is.na(f[2])) f[2] = ""
      return(paste(f, collapse="-"))
    } else {
      return(paste(f, collapse=", "))
    }
  })
  
  if (length(tbl) == 0) {
    tbl = setNames("None", "None")
  }
  
  tbl = data.frame(Sample=s, Filter=names(tbl), Range=unlist(tbl))
  rownames(tbl) = NULL
  return(tbl)
})

gt(barcode_filter_tbl)
```

```{r}
#| label: tbl-preprocess_rna_feature_filters
#| tbl-cap: !expr paste("Filters applied to features of assay", default_assay)

# Print barcode filters
feature_filter = PrepareBarcodeFilter(param("feature_filter"), orig_idents)
feature_filter_tbl = purrr::map_dfr(names(feature_filter), function(s) {
  tbl = purrr::map(feature_filter[[s]], function(f) {
    if (is.numeric(f) & length(f)==2) {
      if (is.na(f[1])) f[1] = ""
      if (is.na(f[2])) f[2] = ""
      return(paste(f, collapse="-"))
    } else {
      return(paste(f, collapse=", "))
    }
  })
  
  if (length(tbl) == 0) {
    tbl = setNames("None", "None")
  }
  
  tbl = data.frame(Sample=s, Filter=names(tbl), Value=unlist(tbl))
  rownames(tbl) = NULL
  return(tbl)
})

gt(feature_filter_tbl)
```

The number of excluded cells and features is as follows: 

```{r}
#| label: tbl-preprocess_rna_filter_barcodes
#| tbl-cap: "Summary of excluded barcodes"

orig_idents = levels(sc$orig.ident)
barcode_filter = PrepareBarcodeFilter(param("barcode_filter"), orig_idents)
barcode_metadata = sc[[]]

# Apply filters to barcodes and record
barcodes_to_exclude = purrr::map(orig_idents, function(s) {
  # Apply user filters
  filter_result = purrr::map(names(barcode_filter[[s]]), function(n) {
    filter = barcode_filter[[s]][[n]]
    if (is.numeric(filter) & length(filter)==2) {
      if (is.na(filter[1])) filter[1] = -Inf
      if (is.na(filter[2])) filter[2] = Inf
      idx_exclude = which(barcode_metadata[[n]] < filter[1] | barcode_metadata[[n]] > filter[2])
    } else {
      idx_exclude = which(!barcode_metadata[[n]] %in% filter)
    }
    return(rownames(barcode_metadata)[idx_exclude])
  })
  names(filter_result) = names(barcode_filter[[s]])
  
  # Samples to drop
  if (s %in% param("samples_to_drop")) {
    idx_exclude = which(barcode_metadata$orig.ident == s)
    filter_result[["samples_to_drop"]] = rownames(barcode_metadata)[idx_exclude]
  } else {
    filter_result[["samples_to_drop"]] = as.character(c())
  }
  
  # Minimum number of cells for a sample to keep
  samples_min_cells = param("samples_min_cells")
  filter_result[["samples_min_cells"]] = as.character(c())
  if (!is.null(samples_min_cells)) {
    idx_exclude = which(barcode_metadata$orig.ident == s)
    if (length(idx_exclude) < samples_min_cells) {
      filter_result[["samples_min_cells"]] = rownames(barcode_metadata)[idx_exclude]
    }
  }
  
  return(filter_result)
})
names(barcodes_to_exclude) = orig_idents

# Summarise
barcodes_to_exclude_tbl = purrr::map_dfr(barcodes_to_exclude, function(s) {
  return(as.data.frame(purrr::map(s, length))) 
  })
rownames(barcodes_to_exclude_tbl) = names(barcodes_to_exclude)
barcodes_to_exclude_tbl$Original = purrr::map_int(orig_idents, function(s) return(sum(barcode_metadata$orig.ident == s)))
barcodes_to_exclude_tbl$Excluded = purrr::map_int(barcodes_to_exclude, function(s) { return(purrr::flatten(s) %>% unique() %>% length())})
barcodes_to_exclude_tbl$PercKept = round((barcodes_to_exclude_tbl$Original - barcodes_to_exclude_tbl$Excluded) / barcodes_to_exclude_tbl$Original * 100, 2)

# Filter
barcodes_to_exclude = purrr::flatten(barcodes_to_exclude) %>% purrr::flatten_chr() %>% unique()
barcodes_to_keep = rownames(barcode_metadata)
barcodes_to_keep = barcodes_to_keep[!barcodes_to_keep %in% barcodes_to_exclude]
sc = subset(sc, cells=barcodes_to_keep)

gt(barcodes_to_exclude_tbl, rownames_to_stub=TRUE)
```

```{r}
#| label: tbl-preprocess_rna_filter_features
#| tbl-cap: "Summary of excluded features"

orig_idents = levels(sc$orig.ident)
feature_filter = PrepareFeatureFilter(param("feature_filter"), orig_idents)
barcode_metadata = sc[[]]
feature_metadata = sc[[default_assay]][]

# Iterate over samples and record a feature if it does not pass the filter
features_to_exclude = purrr::map(orig_idents, function(s) {
  l = paste("counts", s, sep=".")
  
  # Get features from layer (dataset)
  features = rownames(sc[[default_assay]][[l]])
  metadata = feature_metadata[rownames(feature_metadata) %in% features, ]
  
  # Filter
  exclude = metadata[[paste("nBcsThreshold", s, sep="_")]] < feature_filter[[s]][["min_cells"]]
  names(exclude) = rownames(metadata)
  return(exclude)
})
names(features_to_exclude) = orig_idents

# Find features that fail in all samples (get the ones that fail and then apply intersect iteratively)
features_to_exclude_all = purrr::map(features_to_exclude, function(x) return(names(x[x==TRUE]))) %>%
  purrr::reduce(intersect)

# Summarise
features_to_exclude_tbl = purrr::map_dfr(names(features_to_exclude), function(n) {
  # Boolean vector for all features in dataset
  features = features_to_exclude[[n]]
  df = data.frame(Original=length(features), 
                  FailThreshold=sum(features))
  df$PercFailThreshold = round(df$FailThreshold / df$Original * 100, 2)
  
  df$Kept = length(setdiff(names(features), features_to_exclude_all))
  df$PercKept = round(df$Kept / df$Original * 100, 2)
  return(df)
})
rownames(features_to_exclude_tbl) = names(features_to_exclude)

# Remove features
features_to_keep = rownames(sc[[default_assay]])
features_to_keep = features_to_keep[!features_to_keep %in% features_to_exclude_all]
sc = subset(sc, features=features_to_keep)
                             
# Print table
gt(features_to_exclude_tbl, rownames_to_stub=TRUE)
```

After filtering, the size of the Seurat object is: 

```{r preprocess_rna_filter_size}
sc
```

## Quality control post filtering

The updated QC plots are:

```{r}
#| label: preprocess_rna_qcfilt_plots
#| results: asis

orig_idents = levels(sc$orig.ident)
barcode_filter = PrepareBarcodeFilter(param("barcode_filter"), orig_idents)
barcode_metadata = sc[[]]

# QC metrics to plot for cells
qc_features = paste(c("nCount", "nFeature", "pCountsTop50", "pMito"), default_assay, sep="_")
captions = paste(default_assay, c("Number of counts per barcode (filtered)", "Number of features per barcode (filtered)", "Percent counts in top50 features (filtered)", "Percent counts in mitochondrial genes (filtered)"), sep=": ")

if (sum(sc[[paste("pERCC", default_assay, sep="_")]]) > 0) {
  qc_features = c(qc_features, paste(c("pERCC"), default_assay, sep="_"))
  captions = c(captions, paste(default_assay, c("Percent counts in ERCC controls (filtered)"), sep=": "))
}

# Get filter thresholds per QC metrics (for plotting)
qc_thresholds = purrr::map(qc_features, function(f) {
  tresh = purrr::map_dfr(names(barcode_filter), function(n) {
    tr = data.frame(qc_feature=character(), ident=character(), min=numeric(), max=numeric())
    if (f %in% names(barcode_filter[[n]])) {
      tr = data.frame(qc_feature=f, ident=n, min=barcode_filter[[n]][[f]][1], max=barcode_filter[[n]][[f]][2])
    }
    tr$ident = factor(tr$ident, levels=orig_idents)
    tr = tr %>% tidyr::pivot_longer(c(min, max), names_to="threshold", values_to="value")
    return(tr)
  })
})
names(qc_thresholds) = qc_features

# Make plots
plist = Seurat::VlnPlot(sc, features=qc_features, combine=FALSE, pt.size=0, raster=FALSE)
names(plist) = qc_features
plist = purrr::map(seq(plist), function(i) {
  p = plist[[i]]
  
  # Add style
  p = p + AddPlotStyle(legend_position="none", xlab="") +
    theme(axis.text.x=element_text(angle=45, hjust=1))
  
  # Add filter thresholds
  qc_threshold_segments = purrr::pmap(qc_thresholds[[i]], function(qc_feature, ident, threshold, value) {
    return(geom_segment(x=as.integer(ident)-0.5, xend=as.integer(ident)+0.5, y=value, yend=value, linetype=ifelse(threshold=="max", 6, 2), colour="firebrick"))
  })
  p = p + qc_threshold_segments
  return(p)
})

# Generate chunks
chunk_template = "
\`\`\`{r}
#| label: fig-preprocessing_rna_qcfilt_{{type}}
#| fig-asp: 0.5
#| fig-cap: '{{caption}}'
#| echo: false
#| warning: false

print(plist[[{{i}}]])
\`\`\`
"

for (i in seq(plist)) {
  chunk_filled =  knitr::knit_expand(text=chunk_template, type=qc_features[i], i=i, caption=captions[i])
  if(interactive()) {
    EvalKnitrChunk(chunk_filled)
  } else {
    chunk_filled = knitr::knit_child(text=chunk_filled, envir=environment(), quiet=TRUE)
    cat(chunk_filled, sep='\n')
  }
}
```


```{r}
#| label: preprocess_rna_qcfilt_cor_plots
#| results: asis

orig_idents = levels(sc$orig.ident)
barcode_filter = PrepareBarcodeFilter(param("barcode_filter"), orig_idents)
barcode_metadata = sc[[]]

# Correlate QC metrics for cells
qc_feature_cors = list(
  paste(c("nFeature", "nCount"), default_assay, sep="_"),
  paste(c("nFeature", "pMito"), default_assay, sep="_")
)
captions = c("Number of features vs number of counts (filtered)", "Number of features vs number of counts in mitochondrial genes (filtered)")

if (sum(sc[[paste("pERCC", default_assay, sep="_")]]) > 0) {
  qc_feature_cors = c(qc_feature_cors, paste(c("nFeature", "pERCC"), default_assay, sep="_"))
  captions = c(captions, paste(default_assay, c("Number of features vs number of counts in ERCC controls (filtered)"), sep=": "))
}

# Get filter thresholds per QC metrics (for plotting)
qc_thresholds = purrr::map(qc_features, function(f) {
  tresh = purrr::map_dfr(names(barcode_filter), function(n) {
    tr = data.frame(qc_feature=character(), ident=character(), min=numeric(), max=numeric())
    if (f %in% names(barcode_filter[[n]])) {
      tr = data.frame(qc_feature=f, ident=n, min=barcode_filter[[n]][[f]][1], max=barcode_filter[[n]][[f]][2])
    }
    tr$ident = factor(tr$ident, levels=orig_idents)
    tr = tr %>% tidyr::pivot_longer(c(min, max), names_to="threshold", values_to="value")
    return(tr)
  })
})
names(qc_thresholds) = qc_features

# Make plots
plist = purrr::map(qc_feature_cors, function(c) {
  f1 = c[1]
  f2 = c[2]

  # Plot QC feature f1 vs f2
  p = Seurat::FeatureScatter(sc, feature1=f1, feature2=f2, shuffle=TRUE, seed=getOption("random_seed"), raster=ncol(sc)>=getOption("raster.threshold"))
  p = p + AddPlotStyle()
  
  # Add filter thresholds for f1
  qc_threshold_segments = purrr::pmap(qc_thresholds[[f1]], function(qc_feature, ident, threshold, value) {
      return(geom_vline(xintercept=value, linetype=ifelse(threshold=="max", 6, 2), colour="firebrick"))
  })
  p = p + qc_threshold_segments
  
  # Add filter thresholds for f2
  qc_threshold_segments = purrr::pmap(qc_thresholds[[f2]], function(qc_feature, ident, threshold, value) {
      return(geom_hline(yintercept=value, linetype=ifelse(threshold=="max", 6, 2), colour="firebrick"))
  })
  p = p + qc_threshold_segments
  return(p)
})

# Generate chunks
chunk_template = "
\`\`\`{r}
#| label: fig-preprocessing_rna_qcfilt_{{type1}}_vs_{{type2}}
#| fig-asp: 0.5
#| fig-cap: '{{caption}}'
#| echo: false
#| warning: false

print(plist[[{{i}}]])
\`\`\`
"

for (i in seq(plist)) {
  chunk_filled =  knitr::knit_expand(text=chunk_template, type1=qc_feature_cors[[i]][1], type2=qc_feature_cors[[i]][2], i=i, caption=captions[i])
  if(interactive()) {
    EvalKnitrChunk(chunk_filled)
  } else {
    chunk_filled = knitr::knit_child(text=chunk_filled, envir=environment(), quiet=TRUE)
    cat(chunk_filled, sep='\n')
  }
}
```

## Cell Cycle

```{r}

species = param("species")
ensembl_version = param("ensembl")
feature_metadata = sc[[default_assay]][]

# These are the human cell cycle genes
seurat_s_genes = Seurat::cc.genes.updated.2019[["s.genes"]]
seurat_g2m_genes = Seurat::cc.genes.updated.2019[["g2m.genes"]]

# See if we have Ensembl IDs and can use Ensembl to find orthologues
# In case species is human, we just fetch the IDs
ensembl_column = NULL
if ("ensembl_id" %in% colnames(feature_metadata)) {
  ensembl_column = "ensembl_id"
} else if (any(grepl("^ENS", feature_metadata[["feature_id"]]))) {
  ensembl_column = "feature_id"
}

if (!is.null(ensembl_column)) {
  # Use Ensembl
  if (species != "homo_sapiens") {
    # Fetch orthologues via Ensembl
    
  } else {
    # Fetch ids via Ensembl
    seurat_s_genes = EnsemblFetchGeneInfo(ids=seurat_s_genes,
                                          symbols=TRUE,
                                          species=species,
                                          ensembl_version=ensembl_version,
                                          mart_attributes=c(ensembl_id="ensembl_gene_id", ensembl_symbol="external_gene_name"),
                                          useCache=TRUE)
    seurat_s_genes = seurat_s_genes %>% dplyr::filter(!is.na(ensembl_id)) %>% dplyr::pull(ensembl_id)
    idx = which(feature_metadata[, ensembl_column, drop=TRUE] %in% seurat_s_genes)
    seurat_s_genes= rownames(feature_metadata)[idx]

    
  }
  
  
dt = EnsemblFetchGeneInfo(seurat_s_genes, symbols=TRUE, species="homo_sapiens", ensembl_version="98", mart_attributes = c(ensembl_id="ensembl_gene_id", ensembl_symbol="external_gene_name"))
  
} else {
  # Try to match
}
    
if (ensembl_id )
```


## Save Seurat object

```{r}
#| label: preprocess_rna_save_seurat

# Save Seurat object
saveRDS(object=sc, file=file.path(module_dir, "sc.rds"))
```
