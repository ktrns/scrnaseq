---
# Module-specific parameters (that are not already in the profile yaml)
params:
  # Name of the module used in configurations
  module: "integration_rna"
    
  # Relative path to the module directory (which contains the qmd file)
  module_dir: "modules/4_integration/rna"

  # Path to previous module. If null, will be read from the 'chapters' entry in the profile yaml
  prev_module_dir: null
  
  # Default assay.
  default_assay: "RNA"
  
  # For large datasets: Do not keep counts in memory but store on disk in matrix directories. Computations will access only the relevant parts of the data. Once done, matrix directories will be saved together with the Seurat object in the module directory.
  on_disk_counts: true
  
  # For large datasets: Copy matrix directories to a temporary directory for computations. This will improve performance if the temporary directory  has a better performance than normal disks (e.g. SSD). Once done, matrix directories will be copied back to the module directory. The temporary directory will be deleted once the R session exists.
  on_disk_use_tmp: true
  
  # Which normalization should be used for analysis?
  # lognorm (Seurat), scran or sct
  normalisation_method: "lognorm"
  
  # Which method should be used for feature selection?
  # vst (Seurat), scran or sct
  feature_selection_method: "vst"
  
  # Number of variable features to use
  num_variable_features: 3000
  
  # One or more integration method(s) to use. 
  # The following methods are available: null (just merge), CCAIntegration, RPCAIntegration, HarmonyIntegration, FastMNNIntegration, scVIIntegration.
  integration_methods:
  - "FastMNNIntegration"

  # Use sketch-based integration if total number of barcodes is more than
  min_barcodes_for_sketching: 50000
  
  # Number of barcodes in sketch
  num_barcodes_for_sketching: 50000
    
  # Parameters for CCAIntegration
  CCAIntegration: null
  
  # Parameters for RPCAIntegration
  RPCAIntegration: null
  
  # Parameters for HarmonyIntegration
  HarmonyIntegration: null
  
  # Parameters for FastMNNIntegration
  FastMNNIntegration: null
  
  # Parameters for scVIIntegration.
  scVIIntegration: null
    
# Module execution
execute:
  # Should this module be frozen and never re-rendered?
  # - auto: if the code has not changed (default)
  # - true/false: freeze/re-render
  # Does not apply in interactive mode or when explicitly rendering this document via in rstudio
  freeze: "auto"
---

# Integration (RNA)

```{r}
#| label: setup
#| message: false
#| warning: false

# If running code interactively in rstudio, set profile here
# When rendering with quarto, profile is already set and should not be overwritten
if (nchar(Sys.getenv("QUARTO_PROFILE")) == 0) {Sys.setenv("QUARTO_PROFILE" = "default")}

# Source general configurations (always)
source("R/general_configuration.R")

# Source required R functions
source("R/functions_util.R")
source("R/functions_io.R")
source("R/functions_plotting.R")
source("R/functions_analysis.R")


# Load libraries
library(knitr)
library(magrittr)
library(gt)
library(Seurat)
library(SeuratWrappers)
library(ggplot2)
library(future)

# Get module name and directory (needed to access files within the module directory)
module_name = params$module_name
module_dir = params$module_dir

# Parallisation plan for all functions that support future
plan(multisession, workers=4, gc=TRUE)

# Be verbose
verbose=FALSE
```

```{r}
#| label: integration_rna_preparation

###############
# Directories #
###############

# Module directory 'results' contains all output that should be provided together with the final report of the project
dir.create(file.path(module_dir, "results"), showWarnings=FALSE)
files = list.files(path=file.path(module_dir, "results"), full.names=TRUE)
if (length(files) > 0) unlink(files, recursive=TRUE)

# Module directory 'sc' contains the final Seurat object
dir.create(file.path(module_dir, "sc"), showWarnings=FALSE)
files = list.files(path=file.path(module_dir, "sc"), full.names=TRUE)
if (length(files) > 0) unlink(files, recursive=TRUE)

#################
# Seurat object #
#################

# Read in seurat object
if (!is.null(param("prev_module_dir"))) {
  prev_module_dir = param("prev_module_dir")
} else {
  prev_module_dir = PreviousModuleDir(module_dir)
}
prev_sc_obj = file.path(prev_module_dir, "sc", "sc.rds")
if(!file.exists(prev_sc_obj)) {
  stop(FormatMessage("Could not find a sc.rds file in {{prev_module_dir}}. Was the respective module already run?"))
}
sc = SeuratObject::LoadSeuratRds(prev_sc_obj)

# Move on-disk layers to faster temp location if requested
on_disk_counts = param("on_disk_counts")
on_disk_use_tmp = param("on_disk_use_tmp")

if (on_disk_counts & on_disk_use_tmp) {
  on_disk_path = tempdir()
  with_progress({
    sc = UpdateMatrixDirs(sc, dir=on_disk_path)
  }, enable=verbose)
} else {
  on_disk_path = file.path(module_dir, "sc")
}

# Set default assay standard
default_assay = param("default_assay")
if (param("normalisation_method") == "sct") {
  Seurat::DefaultAssay(sc) = paste0(param("default_assay"), "Sct")
} else {
  Seurat::DefaultAssay(sc) = default_assay
}
```

We may not need integration ...

```{r}
#| label: integration_rna_integration

integration_methods = param("integration_methods")
min_barcodes_for_sketching = param("min_barcodes_for_sketching")
num_barcodes_for_sketching = param("num_barcodes_for_sketching")
integration_methods_params = purrr::map(integration_methods, function(method) {
  par_lst = param(method)
  
  # Parse into argument name and value. Interpret values (still strings) as R code.
  if (!is.null(par_lst)) {
    par_lst = stringr::str_split(par_lst, pattern="=", n=2)
    nms = purrr::map(par_lst, 1)
    vls = purrr::map(par_lst, 2)
    vls = purrr::map(vls, function(v) return(eval(parse(text=v))))
    par_lst = setNames(vls, nms)
  }
  return(par_lst)
})
names(integration_methods_params) = integration_methods

normalisation_method = param("normalisation_method")
feature_selection_method = param("feature_selection_method")
num_variable_features = param("num_variable_features")

# Integration not requested or not needed - just join layers
num_datasets = length(SeuratObject::Layers(sc, assay=default_assay, search="^counts"))
num_barcodes = length(SeuratObject::Cells(sc[[default_assay]]))
use_sketching = num_barcodes > min_barcodes_for_sketching

if (length(integration_methods) > 0) {
  # Integration requested and neccessary

  # Do we need to do sketching?
  if (use_sketching) {
    # Create a sketch of the data
    sketched_assay_name = paste(default_assay, "Sketch", sep=".")
    sc = Seurat::SketchData(sc, 
                       ncells=num_barcodes_for_sketching,
                       sketched.assay=sketched_assay_name)
    SeuratObject::Key(sc[[sketched_assay_name]]) = paste0(default_assay, "Sketch", "_") %>% 
      gsub(pattern="\\.", replacement="", x=.) %>%
      tolower()
    SeuratObject::DefaultAssay(sc) = sketched_assay_name
    
    # SCTransform normalization needs to be repeated for the sketch?
    if(normalisation_method == "sct") {
      sct_assay_name = paste(SeuratObject::DefaultAssay(sc), "Sct", sep=".")
      sc = SCTransform(sc, 
                   new.assay.name=sct_assay_name,
                   vst.flavor="v2",
                   variable.features.n=num_variable_features,
                   vars.to.regress=c(),
                   return.only.var.genes=TRUE,
                   verbose=TRUE,
                   seed.use=getOption("random_seed"))
      SeuratObject::Key(sc[[sct_assay_name]]) = paste0(default_assay, "Sketch", "Sct", "_") %>% 
        gsub(pattern="\\.", replacement="", x=.) %>%
        tolower()
      SeuratObject::DefaultAssay(sc) = sct_assay_name
    }
    
    # Find variable features for sketch
    # Runs methods 'vst' or 'scran', method 'sct' was already done when running SCTransform
    if(feature_selection_method != "sct") {
      sc = FindVariableFeaturesWrapper(sc,
                                       feature_selection_method=feature_selection_method,
                                       num_variable_features=num_variable_features,
                                       verbose=verbose)
    }
  }
  
  # Now scale data and run PCA
  sc = Seurat::ScaleData(sc, 
                         verbose=verbose)
  sc = Seurat::RunPCA(sc,
                      seed.use=getOption("random_seed"), 
                      verbose=verbose)
  
  # Integrate
  for(method in integration_methods) {
    
    # New reduction name
    new_reduct = dplyr::case_match(method,
                                   "CCAIntegration" ~ "cca",
                                   "RPCAIntegration" ~ "rpca",
                                   "HarmonyIntegration" ~ "harmony",
                                   "FastMNNIntegration" ~ "mnn",
                                   "scVIIntegration" ~ "scvii")
    new_reduct = paste("integrated", new_reduct, sep=".")
    
    # Additional method-specific arguments passed by config
    additional_args = integration_methods_params[[method]]
    
    # Call wrapper
    sc = IntegrateLayersWrapper(sc=sc,
                                integration_method=method,
                                orig_reduct="pca",
                                new_reduct=new_reduct,
                                additional_args=additional_args,
                                verbose=verbose)
    
    # If sketching was used, project integrated dimensionality reduction of sketch to full dataset
    if (use_sketching) {
      sc = Seurat::ProjectIntegration(sc,
                                      sketched.assay=SeuratObject::DefaultAssay(sc), 
                                      assay=default_assay,
                                      reduction=new_reduct,
                                      reduction.name=paste(new_reduct, "full", sep="."),
                                      reduction.key=paste0(new_reduct, "full", "_") %>% 
                                        gsub(pattern="\\.", replacement="", x=.) %>%
                                        tolower(),
                                      seed=getOption("random_seed"),
                                      verbose=verbose)
    }
  }
  
  # Message
  
  # Reset default assay if sketching was used
  if (use_sketching) {
    SeuratObject::DefaultAssay(sc) = default_assay
  }
} else if (length(integration_methods) == 0) {
  # Integration not requested (just merge)
  glue::glue("\n::: {{.callout-note}}\nSamples are merged. No integration needed!\n:::\n") %>% 
    knitr::asis_output()
  
} else if (num_datasets == 1) {
  # Integration not necessary
  glue::glue("\n::: {{.callout-note}}\nOnly one sample. No integration needed!\n:::\n") %>% 
    knitr::asis_output()
}
```


```{r}
#| label: integration_rna_join_layers
sc = SeuratObject::JoinLayers(sc)

```

