---
# Module-specific parameters (that are not already in the profile yaml)
params:
  # Name of the module used in configurations
  module: "normalization_rna"
    
  # Relative path to the module directory (which contains the qmd file)
  module_dir: "modules/3_normalization/rna"

  # Path to previous module. If null, will be read from the 'chapters' entry in the profile yaml
  prev_module_dir: null
  
  # Default assay.
  default_assay: "RNA"
  
  # Which normalization should be used for analysis?
  # lognorm (Seurat), scran or SCT
  norm_method: "SCT"
  
  # Which method should be used for feature selection?
  # vst (Seurat) or scran
  feature_selection: "scran"
  
  # Number of variable features to use
  num_variable_features: 3000
  
# Module execution
execute:
  # Should this module be frozen and never re-rendered?
  # - auto: if the code has not changed (default)
  # - true/false: freeze/re-render
  # Does not apply in interactive mode or when explicitly rendering this document via in rstudio
  freeze: auto
---

# Normalization (RNA)

```{r}
#| label: setup
#| message: false
#| warning: false

# If running code interactively in rstudio, set profile here
# When rendering with quarto, profile is already set and should not be overwritten
if (nchar(Sys.getenv("QUARTO_PROFILE")) == 0) {Sys.setenv("QUARTO_PROFILE" = "default")}

# Source general configurations (always)
source("R/general_configuration.R")

# Source required R functions
source("R/functions_util.R")
source("R/functions_io.R")
source("R/functions_plotting.R")
source("R/functions_analysis.R")


# Load libraries
library(knitr)
library(magrittr)
library(gt)
library(Seurat)
library(ggplot2)

# Get module name and directory (needed to access files within the module directory)
module_name = params$module_name
module_dir = params$module_dir
```

```{r}
#| label: normalization_rna_preparation

###############
# Directories #
###############

# Module directory 'results' contains all output that should be provided together with the final report of the project
dir.create(file.path(module_dir, "results"), showWarnings=FALSE)

# Module directory 'tmp' contains all intermediate files only used for this module
dir.create(file.path(module_dir, "tmp"), showWarnings=FALSE)

# Module directory 'sc' contains the final Seurat object
dir.create(file.path(module_dir, "sc"), showWarnings=FALSE)

#################
# Seurat object #
#################

# Read in seurat object
if (!is.null(param("prev_module_dir"))) {
  prev_module_dir = param("prev_module_dir")
} else {
  prev_module_dir = PreviousModuleDir(module_dir)
}
prev_sc_obj = file.path(prev_module_dir, "sc", "sc.rds")
if(!file.exists(prev_sc_obj)) {
  stop(FormatMessage("Could not find a sc.rds file in {{prev_module_dir}}. Was the respective module already run?"))
}
sc = readRDS(prev_sc_obj)
default_assay = param("default_assay")
Seurat::DefaultAssay(sc) = default_assay
```


```{r}
#| label: normalization_rna_normalize
#| results: asis

library(progressr)
handlers("cli")


if (param("norm_method") == "lognorm") {
  # LogNormalize
  sc = Seurat::NormalizeData(sc, 
                             assay=default_assay, 
                             normalization.method="LogNormalize", 
                             scale.factor=10000,
                             verbose=TRUE)
  cat("We have used LogNormalize.")
} else if(param("norm_method") == "scran") {
  # Scran
  sc = NormalizeDataScran(sc, 
                      assay=default_assay,
                      layer="counts", 
                      save="data",
                      chunk_size=50000)
  cat("We have used Scran.")
} else if(param("norm_method") == "SCT") {
  # SCTransform
  sc = SCTransform(sc, 
                   assay=default_assay,
                   new.assay.name=paste0(default_assay, "sct"),
                   vst.flavor="v2",
                   variable.features.n=param("num_variable_features"),
                   vars.to.regress=c(),
                   return.only.var.genes=TRUE,
                   seed.use=getOption("random_seed"))
  cat("We have used SCTransform @Hafemeister_2019.")
}
```

We check whether normalisation was successfull.

```{r}

p1 = PlotRLE(sc, assay=default_assay, layer="counts", is_log=FALSE)

if (param("norm_method") == "SCT") {
  p2 = PlotRLE(sc, assay=paste0(default_assay, "sct"), layer="data", is_log=TRUE)
} else {
  p2 = PlotRLE(sc, assay=default_assay, layer="data", is_log=TRUE)
}

```


Then we identify variable features.

```{r}
#| label: normalization_rna_variable_features

# Only LogNormalize and Scran (already done within SCTransform)
if(param("norm_method") != "SCT") {
  if (param("feature_selection") == "vst") {
    sc = Seurat::FindVariableFeatures(sc, 
                                      assay=default_assay, 
                                      selection.method="vst", 
                                      nfeatures=param("num_variable_features"))
  } else if (param("feature_selection") == "scran") {
    sc = FindVariableFeaturesScran(sc,
                                   assay=default_assay,
                                   nfeatures=param("num_variable_features"),
                                   combined=TRUE)
  }
}
```

They look like this:

```{r}
#| label: normalization_rna_variable_features_plots
#| results: asis

if (param("norm_method") == "SCT") {
  selection_method = "sct"
} else {
  selection_method = param("feature_selection")
}

plist = PlotVariableFeatures(sc, 
                     method=selection_method,
                     assay=default_assay,
                     top=10)

n = gsub(pattern="varFeatures_", replacement="", x=names(plist))
captions = GeneratePlotCaptions(names(plist), remove="_\\S+")
captions = paste(captions, "for", n)

# Generate chunks
chunk_template = "
##### {{name}}

\`\`\`{r}
#| label: fig-normalization_rna_variable_features_{{name}}
#| fig-asp: 0.5
#| fig-cap: '{{caption}}'
#| echo: false
#| warning: false

print(plist[[{{i}}]])
\`\`\`
"

cat("::: panel-tabset", sep="\n")
for (i in seq(plist)) {
  chunk_filled =  knitr::knit_expand(text=chunk_template, name=orig_idents[i], i=i, caption=captions[i])
  if(interactive()) {
    EvalKnitrChunk(chunk_filled)
  } else {
    chunk_filled = knitr::knit_child(text=chunk_filled, envir=environment(), quiet=TRUE)
    cat(chunk_filled, sep='\n')
  }
}
cat(":::")

```
